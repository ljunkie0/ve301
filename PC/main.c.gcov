        -:    0:Source:../src/main.c
        -:    0:Graph:main.gcno
        -:    0:Data:main.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: * Copyright 2022 LJunkie
        -:    3: * https://github.com/ljunkie0/ve301
        -:    4: *
        -:    5: * This program is free software; you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation; either version 2 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License along
        -:   16: * with this program; if not, write to the Free Software Foundation, Inc.,
        -:   17: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
        -:   18: */
        -:   19:
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <math.h>
        -:   23:#include <time.h>
        -:   24:#include <signal.h>
        -:   25:#include <netdb.h>
        -:   26:#include <mpd/client.h>
        -:   27:#include "base.h"
        -:   28:#include "menu.h"
        -:   29:#include "audio.h"
        -:   30:#include "weather.h"
        -:   31:#include "bluetooth.h"
        -:   32:#include "sdl_util.h"
        -:   33:
        -:   34:#ifdef RASPBERRY
        -:   35:#ifdef SDL1
        -:   36:#define DEFAULT_WINDOW_WIDTH 320
        -:   37:#define WINDOW_HEIGHT 240
        -:   38:#else
        -:   39:#define DEFAULT_WINDOW_WIDTH 720
        -:   40:#define WINDOW_HEIGHT 576
        -:   41:#endif
        -:   42:#else
        -:   43:#define DEFAULT_WINDOW_WIDTH 320
        -:   44:#define WINDOW_HEIGHT 240
        -:   45:#endif
        -:   46:#define NO_OF_SCALES 60
        -:   47:
        -:   48:#ifdef RASPBERRY
        -:   49:#define DEFAULT_FONT "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
        -:   50:#else
        -:   51:#define DEFAULT_FONT "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
        -:   52:#endif
        -:   53:#define DEFAULT_X_OFFSET 0
        -:   54:#define DEFAULT_Y_OFFSET 0
        -:   55:#define DEFAULT_LABEL_RADIUS 100
        -:   56:#define DEFAULT_SCALES_RADIUS_START 120
        -:   57:#define DEFAULT_SCALES_RADIUS_END 200
        -:   58:#define DEFAULT_ANGLE_OFFSET 0.0
        -:   59:#define DEFAULT_FONT_SIZE 24
        -:   60:#define DEFAULT_INFO_FONT_SIZE 24
        -:   61:#define CALLBACK_SECONDS 5
        -:   62:#define CHECK_INTERNET_SECONDS 5
        -:   63:#define CHECK_BLUETOOTH_SECONDS 1
        -:   64:#define INFO_MENU_SECONDS 14
        -:   65:#define INFO_MENU_ITEM_SECONDS 5
        -:   66:
        -:   67:#define NIGHT_HUE 0.657
        -:   68:#define NIGHT_SAT 0.466
        -:   69:#define NIGHT_VAL 0.161
        -:   70:#define DAY_HUE   0.165
        -:   71:#define DAY_SAT   0.227
        -:   72:#define DAY_VAL   0.971
        -:   73:
        -:   74:#ifdef PERF_TEST
        -:   75:/**
        -:   76: * Performance test
        -:   77: */
        -:   78:#define MENU_ACTION_LISTENER menu_action_listener_dbg
        -:   79:#define MENU_CALL_BACK menu_call_back_dbg
        -:   80:#else
        -:   81:#define MENU_ACTION_LISTENER menu_action_listener
        -:   82:#define MENU_CALL_BACK menu_call_back
        -:   83:#endif
        -:   84:
        -:   85:typedef enum {
        -:   86:    ACTIVE, STANDBY
        -:   87:} state;
        -:   88:
        -:   89:typedef enum {
        -:   90:    OBJ_TYPE_SONG, OBJ_TYPE_PLAYLIST, OBJ_TYPE_DIRECTORY, OBJ_TYPE_TIME
        -:   91:} object_type;
        -:   92:
        -:   93:static const char *time_menu_item_format = "%H:%M";
        -:   94:static const char *bluetooth_label = "Bluetooth";
        -:   95:static int info_menu_item_seconds = INFO_MENU_ITEM_SECONDS;
        -:   96:
        -:   97:#ifndef M_PI
        -:   98:#define M_PI 3.1415926536
        -:   99:#endif
        -:  100:
        -:  101:typedef struct station {
        -:  102:    const char *label;
        -:  103:    const char *url;
        -:  104:    int id;
        -:  105:} station;
        -:  106:
        -:  107:static int last_tm_min;
        -:  108:static struct tm* current_tm_info;
        -:  109:static int hsv_style = 0;
        -:  110:
        -:  111:static time_t info_menu_t = 0;
        -:  112:static time_t callback_t = 0;
        -:  113:static time_t check_internet_t = 0;
        -:  114:static time_t check_bluetooth_t = 0;
        -:  115:
        -:  116:static int internet_available;
        -:  117:
        -:  118:static menu *radio_menu;
        -:  119:static menu *info_menu;
        -:  120:static menu *nav_menu;
        -:  121:static menu *lib_menu;
        -:  122:static menu *root_dir_menu;
        -:  123:static menu *album_menu;
        -:  124:static menu *song_menu;
        -:  125:static menu *current_menu;
        -:  126:static menu_item *time_item;
        -:  127:static menu_item *title_item;
        -:  128:static menu_item *name_item;
        -:  129:static menu_item *weather_item;
        -:  130:static menu_item *temperature_item;
        -:  131:static menu *volume_menu;
        -:  132:static menu_item *volume_menu_item;
        -:  133:static menu *settings_menu;
        -:  134:
        -:  135:static weather wthr;
        -:  136:
        -:  137:static int bt_device_status = 0;
        -:  138:
        -:  139:static menu_ctrl *ctrl;
        -:  140:
        -:  141:static playlist *album_songs = NULL;
        -:  142:
        -:  143:static song *current_song;
        -:  144:
        -:  145:static theme *default_theme = NULL;
        -:  146:static theme *bluetooth_theme = NULL;
        -:  147:static theme *spotify_theme = NULL;
        -:  148:
       16:  149:const char *get_vol_label(int volume) {
       16:  150:    char *vol_txt = malloc(13*sizeof(char));
       16:  151:    sprintf(vol_txt,"Volume: %d%%",volume);
       16:  152:    return vol_txt;
        -:  153:}
        -:  154:
        -:  155:int item_action_update_directories_menu(menu_event evt, menu *m, menu_item *item);
        -:  156:
    #####:  157:station *new_station(const char *label, const char *url) {
    #####:  158:    station *s = malloc(sizeof(station));
    #####:  159:    s->label = label;
    #####:  160:    s->url = url;
    #####:  161:    s->id = add_station(url);
    #####:  162:    log_info(MAIN_CTX, "Adding station %s with id %d\n", s->label, s->id);
    #####:  163:    return s;
        -:  164:}
        -:  165:
      118:  166:void reset_info_menu_timer() {
      118:  167:    time_t timer;
      118:  168:    time(&timer);
      118:  169:    info_menu_t = timer;
      118:  170:    callback_t = timer;
      118:  171:}
        -:  172:
    #####:  173:void update_radio_menu() {
    #####:  174:    menu_clear(radio_menu);
    #####:  175:    playlist *internet_radios = get_internet_radios();
    #####:  176:    if (internet_radios != NULL) {
        -:  177:            unsigned int r = 0;
    #####:  178:            for (r = 0; r < internet_radios->n_songs; r++) {
    #####:  179:                    song *s = internet_radios->songs[r];
    #####:  180:                    menu_item_new(radio_menu, s->title, s, OBJ_TYPE_SONG, NULL, -1, NULL, NULL, -1);
        -:  181:            }
        -:  182:    } else {
    #####:  183:            log_error(MAIN_CTX, "create_menu: playlist is NULL\n");
    #####:  184:            menu_item_new(radio_menu, "FEHLER", NULL, UNKNOWN_OBJECT_TYPE, NULL, -1, NULL, NULL, -1);
        -:  185:    }
    #####:  186:}
        -:  187:
    #####:  188:void update_album_menu() {
    #####:  189:    menu_clear(album_menu);
    #####:  190:    unsigned int a;
    #####:  191:    char **albums = get_albums(&a);
    #####:  192:    if (albums != NULL) {
    #####:  193:        log_info(MAIN_CTX, "Album successfully received\n");
    #####:  194:        unsigned int r = 0;
    #####:  195:        for (r = 0; r < a; r++) {
    #####:  196:            log_info(MAIN_CTX, "Getting album %d\n", r);
    #####:  197:            menu_add_sub_menu(album_menu, albums[r], song_menu, NULL);
        -:  198:        }
        -:  199:    } else {
    #####:  200:        log_error(MAIN_CTX, "create_menu: playlist is NULL\n");
    #####:  201:        menu_item_new(album_menu, "FEHLER", NULL, UNKNOWN_OBJECT_TYPE, NULL, -1, NULL, NULL, -1);
        -:  202:    }
    #####:  203:}
        -:  204:
    #####:  205:void update_song_menu(menu_item *album_item) {
    #####:  206:    log_info(MAIN_CTX, "Update song menu: %s\n", album_item->unicode_label);
    #####:  207:    int id = 0;
    #####:  208:    for (id = 0; id <= song_menu->max_id; id++) {
    #####:  209:        dispose_song((song *)song_menu->item[id]->object);
        -:  210:    }
    #####:  211:    menu_clear(song_menu);
    #####:  212:    if (album_songs) {
    #####:  213:        dispose_playlist(album_songs);
        -:  214:    }
    #####:  215:    album_songs = get_album_songs(album_item->utf8_label);
    #####:  216:    if (album_songs != NULL) {
        -:  217:        unsigned int r = 0;
    #####:  218:        for (r = 0; r < album_songs->n_songs; r++) {
    #####:  219:            song *s = album_songs->songs[r];
    #####:  220:            log_info(MAIN_CTX, "Song: %s\n", s->title);
    #####:  221:            menu_item_new((menu *) album_item->sub_menu, s->title, s, OBJ_TYPE_SONG, NULL, -1, NULL, NULL, -1);
        -:  222:        }
        -:  223:    } else {
    #####:  224:        log_error(MAIN_CTX, "create_menu: playlist is NULL\n");
    #####:  225:        menu_item_new((menu *)album_item->sub_menu, "FEHLER", NULL, UNKNOWN_OBJECT_TYPE, NULL, -1, NULL, NULL, -1);
        -:  226:    }
    #####:  227:}
        -:  228:
        1:  229:void update_directory_menu(menu_item *directory_item) {
        1:  230:    menu *m = (menu *) directory_item->menu;
        1:  231:    menu_ctrl *ctrl = (menu_ctrl *) m->ctrl;
        1:  232:    if (directory_item->sub_menu) {
        1:  233:        menu_clear((menu *)directory_item->sub_menu);
        -:  234:    } else {
    #####:  235:        directory_item->sub_menu = menu_new((menu_ctrl *)m->ctrl, m->n_o_lines);
        -:  236:    }
        1:  237:    menu *sub_menu = (menu *) directory_item->sub_menu;
        1:  238:    struct mpd_connection *mpd_conn = get_mpd_connection();
        1:  239:    if (mpd_conn) {
        1:  240:        if (directory_item->object_type != OBJ_TYPE_DIRECTORY) {
    #####:  241:            log_error(MAIN_CTX, "Item is not of type directory\n");
    #####:  242:            return;
        -:  243:        }
        1:  244:        const char *dir = (const char *) directory_item->object;
        1:  245:        if (!mpd_send_list_meta(mpd_conn,dir)) {
    #####:  246:            log_error(MAIN_CTX, "Could not list directory %s\n", dir);
    #####:  247:            return;
        -:  248:        }
        1:  249:        struct mpd_entity *entity = mpd_recv_entity(mpd_conn);
        2:  250:        while (entity) {
        1:  251:            log_info(MAIN_CTX, "Type: %d\n", mpd_entity_get_type(entity));
        1:  252:            enum mpd_entity_type type = mpd_entity_get_type(entity);
        1:  253:            if (type == MPD_ENTITY_TYPE_DIRECTORY) {
    #####:  254:                const struct mpd_directory *sub_dir = mpd_entity_get_directory(entity);
    #####:  255:                const char *path = mpd_directory_get_path(sub_dir);
    #####:  256:                char *name = get_name_from_path(path);
    #####:  257:                log_info(MAIN_CTX, "Directory %s\n", name);
    #####:  258:                menu *sub_sub_menu = menu_new(ctrl,m->n_o_lines);
    #####:  259:                menu_item *sub_sub_menu_item = menu_add_sub_menu(sub_menu,name,sub_sub_menu, item_action_update_directories_menu);
    #####:  260:                sub_sub_menu_item->object = (const void *) path;
    #####:  261:                sub_sub_menu_item->object_type = OBJ_TYPE_DIRECTORY;
        1:  262:            } else if (type == MPD_ENTITY_TYPE_SONG) {
    #####:  263:                const struct mpd_song *s = mpd_entity_get_song(entity);
    #####:  264:                const char *uri = mpd_song_get_uri(s);
    #####:  265:                char *name = get_name_from_path(uri);
    #####:  266:                log_info(MAIN_CTX, "Song: %s\n", name);
    #####:  267:                song *my_song = malloc(sizeof(song));
    #####:  268:                my_song->name = name;
    #####:  269:                my_song->url = uri;
    #####:  270:                my_song->id = mpd_song_get_id(s);
    #####:  271:                my_song->title = (char *) mpd_song_get_tag(s,MPD_TAG_TITLE,0);
    #####:  272:                menu_item_new(sub_menu,my_song->title,my_song,OBJ_TYPE_SONG,NULL,-1, NULL, NULL, -1);
        -:  273:            }
        1:  274:            entity = mpd_recv_entity(mpd_conn);
        -:  275:        }
        -:  276:    } else {
        -:  277:
        1:  278:    }
        -:  279:}
        -:  280:
        7:  281:void update_time_item(menu_item *time_menu_item) {
        7:  282:    last_tm_min = current_tm_info->tm_min;
        7:  283:    char *buffer = malloc(25 * sizeof(char));
        7:  284:    strftime(buffer, 25, time_menu_item_format, current_tm_info);
        7:  285:    menu_item_update_label(time_menu_item, buffer);
        7:  286:    log_debug(MAIN_CTX, "free(buffer))\n");
        7:  287:    log_debug(MAIN_CTX, "buffer = %p\n", buffer);
        7:  288:    free(buffer);
        7:  289:}
        -:  290:
    #####:  291:int change_x_offset(menu_ctrl *ctrl, int c) {
    #####:  292:    menu_ctrl_set_offset(ctrl,ctrl->x_offset + c,ctrl->y_offset);
    #####:  293:    set_config_value_int("x_offset",ctrl->x_offset);
    #####:  294:    menu_ctrl_draw(ctrl);
    #####:  295:    return 0;
        -:  296:}
        -:  297:
    #####:  298:int change_y_offset(menu_ctrl *ctrl, int c) {
    #####:  299:    menu_ctrl_set_offset(ctrl,ctrl->x_offset,ctrl->y_offset + c);
    #####:  300:    set_config_value_int("y_offset",ctrl->y_offset);
    #####:  301:    menu_ctrl_draw(ctrl);
    #####:  302:    return 0;
        -:  303:}
        -:  304:
        1:  305:int item_action_update_directories_menu(menu_event evt, menu *m, menu_item *item) {
        1:  306:    update_directory_menu(item);
        1:  307:    return 0;
        -:  308:}
        -:  309:
    #####:  310:int menu_action_listener_dbg(menu_event evt, menu *m_ptr, menu_item *item_ptr) {
    #####:  311:    return 0;
        -:  312:}
        -:  313:
      118:  314:int menu_action_listener(menu_event evt, menu *m_ptr, menu_item *item_ptr) {
      118:  315:    log_config(MAIN_CTX, "action(%d)\n",evt);
      118:  316:    if (evt == ACTIVATE) {
        1:  317:        menu_item *item = (menu_item *) item_ptr;
        1:  318:        log_debug(MAIN_CTX, "Action: %s\n", item->unicode_label);
        1:  319:        if (item->is_sub_menu) {
    #####:  320:            log_info(MAIN_CTX, "Sub menu: %s\n", item->unicode_label);
    #####:  321:            if (item->sub_menu == radio_menu) {
    #####:  322:                update_radio_menu();
    #####:  323:            } else if (item->sub_menu == album_menu) {
    #####:  324:                update_album_menu();
    #####:  325:            } else if (item->sub_menu == song_menu) {
    #####:  326:                update_song_menu(item);
    #####:  327:            } else if (item->object_type == OBJ_TYPE_DIRECTORY || item->sub_menu == root_dir_menu) {
    #####:  328:                update_directory_menu(item);
        -:  329:            }
       1*:  330:        } else if (item->object && item->object_type == OBJ_TYPE_SONG) {
    #####:  331:            m_ptr->active_id = item->id;
    #####:  332:            song *s = (song *) item->object;
    #####:  333:            song *p = get_playing_song();
    #####:  334:            if (!p || (p->id != s->id)) {
    #####:  335:                if (!play_song(s)) {
    #####:  336:                    log_error(MAIN_CTX, "Could not play song %s", s->title);
        -:  337:                }
    #####:  338:                song *current_song = get_playing_song();
    #####:  339:                if (current_song) {
    #####:  340:                    menu_item_update_label(name_item, current_song->name);
        -:  341:                }
    #####:  342:            } else if (p) {
    #####:  343:                stop();
        -:  344:            }
        1:  345:        } else if (((menu *)item->menu)->transient) {
        1:  346:            if (ctrl->active) {
    #####:  347:                menu_open(ctrl->active);
        -:  348:            } else {
        1:  349:                menu_open(nav_menu);
        -:  350:            }
        -:  351:        }
      117:  352:    } else if (evt == ACTIVATE_1) {
        -:  353:        //stand_by();
      117:  354:    } else if (evt == TURN_LEFT_1) {
        8:  355:            menu_item_show(volume_menu_item);
        8:  356:            decrease_volume();
        8:  357:            const char *vol_label = get_vol_label(get_volume());
        8:  358:            menu_item_update_label(volume_menu_item,vol_label);
        8:  359:            menu_item_show(volume_menu_item);
      109:  360:    } else if (evt == TURN_RIGHT_1) {
        7:  361:            menu_item_show(volume_menu_item);
        7:  362:            increase_volume();
        7:  363:            const char *vol_label = get_vol_label(get_volume());
        7:  364:            menu_item_update_label(volume_menu_item,vol_label);
        7:  365:            menu_item_show(volume_menu_item);
      102:  366:    } else if (evt == DISPOSE) {
    #####:  367:        menu_item *item = (menu_item *) item_ptr;
    #####:  368:        const void *obj = item->object;
    #####:  369:        if (obj && item->menu != radio_menu) {
    #####:  370:            if (item->object_type == OBJ_TYPE_DIRECTORY || item->object_type == OBJ_TYPE_SONG) {
    #####:  371:                log_debug(MAIN_CTX, "free(%p)\n",obj);
    #####:  372:                free((void *)obj);
    #####:  373:            } else if (item->object_type == OBJ_TYPE_SONG) {
    #####:  374:                dispose_song((song *)obj);
        -:  375:            }
        -:  376:        }
        -:  377:    }
        -:  378:
      118:  379:    reset_info_menu_timer();
        -:  380:
      118:  381:    return 0;
        -:  382:}
        -:  383:
    #####:  384:int change_label_radius(menu_ctrl *ctrl, int c) {
    #####:  385:    int label_radius = ctrl->root[0]->radius_labels + c;
    #####:  386:    set_config_value_int("radius_labels",label_radius);
    #####:  387:    menu_ctrl_set_radii(ctrl, label_radius, -1, -1);
    #####:  388:    menu_ctrl_draw(ctrl);
    #####:  389:    return 0;
        -:  390:}
        -:  391:
    #####:  392:int change_scale_radius(menu_ctrl *ctrl, int c) {
    #####:  393:    int scale_radius = ctrl->radius_scales_start + c;
    #####:  394:    set_config_value_int("radius_scales_start",scale_radius);
    #####:  395:    menu_ctrl_set_radii(ctrl, scale_radius, -1, -1);
    #####:  396:    menu_ctrl_draw(ctrl);
    #####:  397:    return 0;
        -:  398:}
        -:  399:
    #####:  400:int item_action_x_offset(menu_event evt, menu *m, menu_item *item) {
    #####:  401:    if (evt == TURN_LEFT_1) {
    #####:  402:        change_x_offset(m->ctrl,-1);
    #####:  403:        menu_item_show(item);
    #####:  404:        reset_info_menu_timer();
    #####:  405:    } else if (evt == TURN_RIGHT_1) {
    #####:  406:        change_x_offset(m->ctrl,1);
    #####:  407:        menu_item_show(item);
    #####:  408:        reset_info_menu_timer();
        -:  409:    }
    #####:  410:    return 0;
        -:  411:}
        -:  412:
    #####:  413:int item_action_y_offset(menu_event evt, menu *m, menu_item *item) {
    #####:  414:    if (evt == TURN_LEFT_1) {
    #####:  415:        change_y_offset(m->ctrl,1);
    #####:  416:        menu_item_show(item);
    #####:  417:        reset_info_menu_timer();
    #####:  418:    } else if (evt == TURN_RIGHT_1) {
    #####:  419:        change_y_offset(m->ctrl,-1);
    #####:  420:        menu_item_show(item);
    #####:  421:        reset_info_menu_timer();
        -:  422:    }
    #####:  423:    return 0;
        -:  424:}
        -:  425:
    #####:  426:int item_action_label_radius(menu_event evt, menu *m, menu_item *item) {
    #####:  427:    if (evt == TURN_LEFT_1) {
    #####:  428:        change_label_radius(m->ctrl,1);
    #####:  429:        menu_item_show(item);
    #####:  430:        reset_info_menu_timer();
    #####:  431:    } else if (evt == TURN_RIGHT_1) {
    #####:  432:        change_label_radius(m->ctrl,-1);
    #####:  433:        menu_item_show(item);
    #####:  434:        reset_info_menu_timer();
        -:  435:    }
    #####:  436:    return 0;
        -:  437:}
        -:  438:
    #####:  439:int item_action_background_hue(menu_event evt, menu *m, menu_item *item) {
    #####:  440:    if (evt == TURN_LEFT_1) {
    #####:  441:        double h,s,v;
    #####:  442:        rgb_to_hsv(m->ctrl->background_color->r,m->ctrl->background_color->g,m->ctrl->background_color->b,&h,&s,&v);
    #####:  443:        h = h + 2;
    #####:  444:        menu_ctrl_set_bg_color_hsv(m->ctrl,h,s,v);
    #####:  445:        Uint8 r,g,b;
    #####:  446:        hsv_to_rgb(h,s,v,&r,&g,&b);
    #####:  447:        char *html = rgb_to_html(r,g,b);
    #####:  448:        set_config_value("background_color",html);
    #####:  449:        free(html);
    #####:  450:        menu_ctrl_draw(ctrl);
    #####:  451:        reset_info_menu_timer();
    #####:  452:    } else if (evt == TURN_RIGHT_1) {
    #####:  453:        double h,s,v;
    #####:  454:        rgb_to_hsv(m->ctrl->background_color->r,m->ctrl->background_color->g,m->ctrl->background_color->b,&h,&s,&v);
    #####:  455:        h = h - 2;
    #####:  456:        menu_ctrl_set_bg_color_hsv(m->ctrl,h,s,v);
    #####:  457:        Uint8 r,g,b;
    #####:  458:        hsv_to_rgb(h,s,v,&r,&g,&b);
    #####:  459:        char *html = rgb_to_html(r,g,b);
    #####:  460:        set_config_value("background_color",html);
    #####:  461:        free(html);
    #####:  462:        menu_ctrl_draw(ctrl);
    #####:  463:        reset_info_menu_timer();
        -:  464:    }
    #####:  465:    return 0;
        -:  466:}
        -:  467:
    #####:  468:int item_action_default_hue(menu_event evt, menu *m, menu_item *item) {
    #####:  469:    if (evt == TURN_LEFT_1) {
    #####:  470:        double h,s,v;
    #####:  471:        rgb_to_hsv(m->ctrl->default_color->r,m->ctrl->default_color->g,m->ctrl->default_color->b,&h,&s,&v);
    #####:  472:        Uint8 r,g,b;
    #####:  473:        h = h + 5;
    #####:  474:        hsv_to_rgb(h,s,v,&r,&g,&b);
    #####:  475:        menu_ctrl_set_default_color_rgb(m->ctrl,r,g,b);
    #####:  476:        menu_ctrl_draw(ctrl);
    #####:  477:        reset_info_menu_timer();
    #####:  478:    } else if (evt == TURN_RIGHT_1) {
    #####:  479:        double h,s,v;
    #####:  480:        rgb_to_hsv(m->ctrl->default_color->r,m->ctrl->default_color->g,m->ctrl->default_color->b,&h,&s,&v);
    #####:  481:        Uint8 r,g,b;
    #####:  482:        h = h - 5;
    #####:  483:        hsv_to_rgb(h,s,v,&r,&g,&b);
    #####:  484:        menu_ctrl_set_default_color_rgb(m->ctrl,r,g,b);
    #####:  485:        menu_ctrl_draw(ctrl);
    #####:  486:        reset_info_menu_timer();
        -:  487:    }
    #####:  488:    return 0;
        -:  489:}
        -:  490:
    #####:  491:int item_action_selected_hue(menu_event evt, menu *m, menu_item *item) {
    #####:  492:    if (evt == TURN_LEFT_1) {
    #####:  493:        double h,s,v;
    #####:  494:        rgb_to_hsv(m->ctrl->selected_color->r,m->ctrl->selected_color->g,m->ctrl->selected_color->b,&h,&s,&v);
    #####:  495:        Uint8 r,g,b;
    #####:  496:        h = h + 5;
    #####:  497:        hsv_to_rgb(h,s,v,&r,&g,&b);
    #####:  498:        menu_ctrl_set_selected_color_rgb(m->ctrl,r,g,b);
    #####:  499:        menu_ctrl_draw(ctrl);
    #####:  500:        reset_info_menu_timer();
    #####:  501:    } else if (evt == TURN_RIGHT_1) {
    #####:  502:        double h,s,v;
    #####:  503:        rgb_to_hsv(m->ctrl->selected_color->r,m->ctrl->selected_color->g,m->ctrl->selected_color->b,&h,&s,&v);
    #####:  504:        Uint8 r,g,b;
    #####:  505:        h = h - 5;
    #####:  506:        hsv_to_rgb(h,s,v,&r,&g,&b);
    #####:  507:        menu_ctrl_set_selected_color_rgb(m->ctrl,r,g,b);
    #####:  508:        menu_ctrl_draw(ctrl);
    #####:  509:        reset_info_menu_timer();
        -:  510:    }
    #####:  511:    return 0;
        -:  512:}
        -:  513:
    #####:  514:int item_action_active_hue(menu_event evt, menu *m, menu_item *item) {
    #####:  515:    if (evt == TURN_LEFT_1) {
    #####:  516:        double h,s,v;
    #####:  517:        rgb_to_hsv(m->ctrl->activated_color->r,m->ctrl->activated_color->g,m->ctrl->activated_color->b,&h,&s,&v);
    #####:  518:        Uint8 r,g,b;
    #####:  519:        h = h + 5;
    #####:  520:        hsv_to_rgb(h,s,v,&r,&g,&b);
    #####:  521:        menu_ctrl_set_active_color_rgb(m->ctrl,r,g,b);
    #####:  522:        menu_ctrl_draw(ctrl);
    #####:  523:        reset_info_menu_timer();
    #####:  524:    } else if (evt == TURN_RIGHT_1) {
    #####:  525:        double h,s,v;
    #####:  526:        rgb_to_hsv(m->ctrl->activated_color->r,m->ctrl->activated_color->g,m->ctrl->activated_color->b,&h,&s,&v);
    #####:  527:        Uint8 r,g,b;
    #####:  528:        h = h - 5;
    #####:  529:        hsv_to_rgb(h,s,v,&r,&g,&b);
    #####:  530:        menu_ctrl_set_active_color_rgb(m->ctrl,r,g,b);
    #####:  531:        menu_ctrl_draw(ctrl);
    #####:  532:        reset_info_menu_timer();
        -:  533:    }
    #####:  534:    return 0;
        -:  535:}
        -:  536:
    #####:  537:int item_action_store_config(menu_event evt, menu *m, menu_item *item) {
    #####:  538:    write_config();
    #####:  539:    return 0;
        -:  540:}
        -:  541:
    #####:  542:int item_action_scale_radius_decrease(menu_event evt, menu *m, menu_item *item) {
    #####:  543:    change_scale_radius(m->ctrl,-10);
    #####:  544:    return 0;
        -:  545:}
        -:  546:
        3:  547:theme *get_config_theme(char *theme_name) {
        3:  548:    theme *th = malloc (sizeof(theme));
        3:  549:    th->background_color = get_config_value_group("background_color", get_config_value("background_color", "#ffffff"), theme_name);
        3:  550:    th->bg_color_of_time = get_config_value_int_group("bg_color_from_time", get_config_value_int("bg_color_from_time", 0), theme_name);
        3:  551:    th->scale_color = get_config_value_group("scale_color", get_config_value("scale_color", "#ff0000"), theme_name);
        3:  552:    th->indicator_color = get_config_value_group("indicator_color", get_config_value("indicator_color", "#ff0000"), theme_name);
        3:  553:    th->default_color = get_config_value_group("default_color", get_config_value("default_color", "#00ff00"), theme_name);
        3:  554:    th->selected_color = get_config_value_group("selected_color", get_config_value("selected_color", "#0000ff"), theme_name);
        3:  555:    th->activated_color = get_config_value_group("activated_color", get_config_value("activated_color", "#00ffff"), theme_name);
        3:  556:    th->bg_image_path = get_config_value_group("bg_image_path", get_config_value("bg_image_path", 0), theme_name);
        3:  557:    th->font_bumpmap = get_config_value_int_group("font_bumpmap", get_config_value_int("font_bumpmap", 0), theme_name);
        3:  558:    th->shadow_offset = get_config_value_int_group("shadow_offset",get_config_value_int("shadow_offset",0), theme_name);
        3:  559:    th->shadow_alpha = get_config_value_int_group("shadow_alpha", get_config_value_int("shadow_alpha", 0), theme_name);
        3:  560:    th->bg_color_palette = NULL;
        3:  561:    th->bg_cp_colors = 0;
        3:  562:    th->fg_color_palette = NULL;
        3:  563:    th->fg_cp_colors = 0;
        -:  564:
        3:  565:    char *bg_color_palette = get_config_value("bg_color_palette", 0);
        3:  566:    if (bg_color_palette) {
    #####:  567:        th->bg_cp_colors = 0;
    #####:  568:        char *color = strtok(bg_color_palette,",");
    #####:  569:        while (color != NULL) {
    #####:  570:            th->bg_cp_colors = th->bg_cp_colors + 1;
    #####:  571:            th->bg_color_palette = realloc(th->bg_color_palette,th->bg_cp_colors*sizeof(char *));
    #####:  572:            th->bg_color_palette[th->bg_cp_colors-1] = color;
    #####:  573:            color = strtok(NULL,",");
        -:  574:        }
        -:  575:    }
        -:  576:
        3:  577:    char *fg_color_palette = get_config_value("fg_color_palette", 0);
        3:  578:    if (fg_color_palette) {
    #####:  579:        th->fg_cp_colors = 0;
    #####:  580:        char *color = strtok(fg_color_palette,",");
    #####:  581:        while (color != NULL) {
    #####:  582:            th->fg_cp_colors = th->fg_cp_colors + 1;
    #####:  583:            th->fg_color_palette = realloc(th->fg_color_palette,th->fg_cp_colors*sizeof(char *));
    #####:  584:            th->fg_color_palette[th->fg_cp_colors-1] = color;
    #####:  585:            color = strtok(NULL,",");
        -:  586:        }
        -:  587:    }
        -:  588:
        3:  589:    return th;
        -:  590:}
        -:  591:
    #####:  592:void free_theme(theme *th) {
    #####:  593:    log_debug(MAIN_CTX, "free_theme(%p)\n",th);
    #####:  594:    if (th->background_color)
    #####:  595:        free(th->background_color);
    #####:  596:    if (th->scale_color)
    #####:  597:        free(th->scale_color);
    #####:  598:    if (th->indicator_color)
    #####:  599:        free(th->indicator_color);
    #####:  600:    if (th->default_color)
    #####:  601:        free(th->default_color);
    #####:  602:    if (th->selected_color)
    #####:  603:        free(th->selected_color);
    #####:  604:    if (th->activated_color)
    #####:  605:        free(th->activated_color);
    #####:  606:    if (th->bg_image_path)
    #####:  607:        free(th->bg_image_path);
    #####:  608:    if (th->bg_color_palette)
    #####:  609:        free(th->bg_color_palette);
    #####:  610:    if (th->fg_color_palette)
    #####:  611:        free(th->fg_color_palette);
    #####:  612:    free(th);
    #####:  613:}
        -:  614:
        -:  615:static time_t info_menu_t_dbg = -1;
        -:  616:
        -:  617:static long perf_timer_ms = 0;
        -:  618:// #define SECS_IN_DAY (24 * 60 * 60)
        -:  619:
    #####:  620:int menu_call_back_dbg(menu_ctrl *m_ptr) {
        -:  621:
    #####:  622:    menu_ctrl *ctrl = (menu_ctrl *) m_ptr;
        -:  623:
    #####:  624:    if (ctrl->current != radio_menu) {
    #####:  625:        menu_open(radio_menu);
        -:  626:    }
        -:  627:
    #####:  628:    if (ctrl && ctrl->current) {
    #####:  629:        int current_id = ctrl->current->current_id+1;
    #####:  630:        if (current_id > ctrl->current->max_id) {
    #####:  631:            current_id = 0;
        -:  632:        }
        -:  633:
    #####:  634:        struct timespec perf_timer_s, perf_timer_e;
    #####:  635:        clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &perf_timer_s);
    #####:  636:        long msecs_s = perf_timer_s.tv_sec * 1000 + perf_timer_s.tv_nsec / 1000000;
    #####:  637:        menu_item_warp_to(ctrl->current->item[current_id]);
    #####:  638:        clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &perf_timer_e);
    #####:  639:        long msecs_e = perf_timer_e.tv_sec * 1000 + perf_timer_e.tv_nsec / 1000000;
        -:  640:
    #####:  641:        long msecs_p = msecs_e - msecs_s;
    #####:  642:        perf_timer_ms += msecs_p;
        -:  643:
        -:  644:/*        printf("%-15s: %10jd.%03ld (", "START",
        -:  645:               (intmax_t) perf_timer_s.tv_sec, perf_timer_s.tv_nsec / 1000000);
        -:  646:        long days = perf_timer_s.tv_sec / SECS_IN_DAY;
        -:  647:        if (days > 0)
        -:  648:            printf("%ld days + ", days);
        -:  649:        printf("%2dh %2dm %2ds",
        -:  650:               (int) (perf_timer_s.tv_sec % SECS_IN_DAY) / 3600,
        -:  651:               (int) (perf_timer_s.tv_sec % 3600) / 60,
        -:  652:               (int) perf_timer_s.tv_sec % 60);
        -:  653:        printf(")\n");
        -:  654:
        -:  655:        printf("%-15s: %10jd.%03ld (", "END",
        -:  656:               (intmax_t) perf_timer_e.tv_sec, perf_timer_e.tv_nsec / 1000000);
        -:  657:        days = perf_timer_e.tv_sec / SECS_IN_DAY;
        -:  658:        if (days > 0)
        -:  659:            printf("%ld days + ", days);
        -:  660:        printf("%2dh %2dm %2ds",
        -:  661:               (int) (perf_timer_e.tv_sec % SECS_IN_DAY) / 3600,
        -:  662:               (int) (perf_timer_e.tv_sec % 3600) / 60,
        -:  663:               (int) perf_timer_e.tv_sec % 60);
        -:  664:        printf(")\n");
        -:  665:        perf_timer_ns += 1000000 * (perf_timer_e.tv_sec - perf_timer_s.tv_sec) + perf_timer_e.tv_nsec - perf_timer_s.tv_nsec;
        -:  666:*/
        -:  667:
    #####:  668:        time_t timer;
    #####:  669:        time(&timer);
    #####:  670:        current_tm_info = localtime(&timer);
        -:  671:
    #####:  672:        if (info_menu_t_dbg < 0) {
    #####:  673:            info_menu_t_dbg = timer;
        -:  674:        }
        -:  675:
    #####:  676:        long time_diff = timer - info_menu_t_dbg;
        -:  677:
    #####:  678:        if (time_diff > 30) {
    #####:  679:            printf("Time: %ld\n", perf_timer_ms);
    #####:  680:            menu_ctrl_quit(ctrl);
    #####:  681:            base_close();
    #####:  682:            exit(0);
        -:  683:        }
        -:  684:    }
        -:  685:
    #####:  686:    return 1;
        -:  687:}
        -:  688:
     3507:  689:int menu_call_back(menu_ctrl *m_ptr) {
        -:  690:
     3507:  691:    log_debug(MAIN_CTX, "Start: Callback\n");
        -:  692:
     3507:  693:    menu_ctrl *ctrl = (menu_ctrl *) m_ptr;
        -:  694:
     3507:  695:    time_t timer;
     3507:  696:    time(&timer);
     3507:  697:    current_tm_info = localtime(&timer);
        -:  698:
     3507:  699:    long time_diff = timer - info_menu_t;
     3507:  700:    long callback_diff = timer - callback_t;
     3507:  701:    long check_internet_diff = timer - check_internet_t;
     3507:  702:    long check_bluetooth_diff = timer - check_bluetooth_t;
        -:  703:
     3507:  704:    if (ctrl->current != info_menu) {
     1873:  705:        current_menu = ctrl->current;
        -:  706:    }
        -:  707:
     3507:  708:    log_debug(MAIN_CTX, "Callback diff: %d\n", callback_diff);
        -:  709:
     3507:  710:    if (check_internet_diff > CHECK_INTERNET_SECONDS) {
        -:  711:
       13:  712:        check_internet_t = timer;
       13:  713:        internet_available = check_internet();
        -:  714:
        -:  715:    }
        -:  716:
     3507:  717:    if (check_bluetooth_diff > CHECK_BLUETOOTH_SECONDS) {
     3507:  718:        if (bt_connection_signal()) {
    #####:  719:            if (bt_is_connected()) {
    #####:  720:                if (!bt_device_status) {
    #####:  721:                    bt_device_status = 1;
    #####:  722:                    stop();
    #####:  723:                    if (bluetooth_theme) {
    #####:  724:                        menu_ctrl_apply_theme(ctrl, bluetooth_theme);
        -:  725:                    }
    #####:  726:                    menu_item_update_label(title_item, "Bluetooth");
    #####:  727:                    menu_item_update_label(name_item, "Bluetooth");
        -:  728:                }
        -:  729:
    #####:  730:                char *title = bt_get_title();
    #####:  731:                if (title) {
    #####:  732:                    menu_item_update_label(title_item, title);
        -:  733:                } else {
    #####:  734:                    menu_item_update_label(title_item, bluetooth_label);
        -:  735:                }
        -:  736:
    #####:  737:                char *artist = bt_get_artist();
    #####:  738:                if (artist) {
    #####:  739:                    menu_item_update_label(name_item, artist);
        -:  740:                } else {
    #####:  741:                    menu_item_update_label(name_item, bluetooth_label);
        -:  742:                }
        -:  743:
        -:  744:            } else {
    #####:  745:                if (bt_device_status) {
    #####:  746:                    menu_ctrl_apply_theme(ctrl, default_theme);
    #####:  747:                    menu_item_update_label(title_item, "VE301");
    #####:  748:                    menu_item_update_label(name_item, "VE301");
    #####:  749:                    bt_device_status = 0;
        -:  750:                }
        -:  751:            }
        -:  752:        }
        -:  753:    }
        -:  754:
     3507:  755:    if (callback_diff > CALLBACK_SECONDS) {
        -:  756:
        7:  757:        callback_t = timer;
        -:  758:
        7:  759:        if (hsv_style) {
        -:  760:
    #####:  761:            double day_seconds = (current_tm_info->tm_sec + current_tm_info->tm_min * 60.0 + current_tm_info->tm_hour * 3600.0);
    #####:  762:            log_info(MAIN_CTX, "Day seconds: %f\n", day_seconds);
    #####:  763:            double day_fraction = day_seconds / 86400.0;
    #####:  764:            log_info(MAIN_CTX, "Day fraction: %f\n", day_fraction);
    #####:  765:            double color_temp = 1000.0 + day_fraction * (11100.0 - 1000.0);
    #####:  766:            log_info(MAIN_CTX, "Color temp: %f\n", color_temp);
        -:  767:
    #####:  768:            Uint8 r,g,b;
        -:  769:
    #####:  770:            double value = 0.5 * (1.0-cos(2.0*day_fraction*M_PI));
        -:  771:
    #####:  772:            color_temp_to_rgb(color_temp,&r,&g,&b,value);
        -:  773:
    #####:  774:            menu_ctrl_set_bg_color_rgb(ctrl, r,g,b);
        -:  775:
    #####:  776:            if (value > 0.2) {
    #####:  777:                menu_ctrl_set_active_color_hsv(ctrl, 0, 0, 0.0);
    #####:  778:                menu_ctrl_set_default_color_hsv(ctrl, 0, 0, 0.0);
    #####:  779:                menu_ctrl_set_selected_color_hsv(ctrl, 0, 0, 0.0);
        -:  780:            } else {
    #####:  781:                menu_ctrl_set_active_color_hsv(ctrl, 0, 0, 1.0);
    #####:  782:                menu_ctrl_set_default_color_hsv(ctrl, 0, 0, 1.0);
    #####:  783:                menu_ctrl_set_selected_color_hsv(ctrl, 0, 0, 1.0);
        -:  784:            }
        -:  785:
        -:  786:        }
        -:  787:
        7:  788:        if (!bt_device_status) {
        7:  789:            current_song = get_playing_song();
        7:  790:            if (current_song) {
        7:  791:                log_debug(MAIN_CTX, "Current song: %s\n", current_song->title);
        7:  792:                if (current_song->title && (strlen(current_song->title) > 0) && strncmp(current_song->title, "N/A", 3)) {
        7:  793:                    menu_item_update_label(title_item, current_song->title);
        -:  794:                }
        7:  795:                if (current_song->name && (strlen(current_song->name) > 0) && strncmp(current_song->name, "N/A", 3)) {
        7:  796:                    menu_item_update_label(name_item, current_song->name);
        -:  797:                }
        -:  798:            }
        -:  799:        }
        -:  800:
        7:  801:        if (weather_item && temperature_item) {
        7:  802:            char *temp_str = malloc(10*sizeof(char));
        7:  803:            sprintf(temp_str,"%.1f°C",((double)round(10.0*wthr.temp))/10);
        7:  804:            menu_item_update_label(temperature_item,temp_str);
        -:  805:
        7:  806:            if (wthr.weather_icon) {
        7:  807:                menu_item_update_label(weather_item,wthr.weather_icon);
        -:  808:            }
        -:  809:        }
        -:  810:
        7:  811:        update_time_item(time_item);
        -:  812:
        -:  813:    }
        -:  814:
     3507:  815:    if (time_diff > info_menu_item_seconds) {
        4:  816:        info_menu_t = timer;
        4:  817:        if (internet_available) {
        4:  818:            int current_id = ctrl->root[0]->current_id+1;
        4:  819:            if (current_id > ctrl->root[0]->max_id) {
    #####:  820:                current_id = 0;
        -:  821:            }
        4:  822:            menu_item_warp_to(ctrl->root[0]->item[current_id]);
        -:  823:        } else {
    #####:  824:            menu_item_update_label(title_item,"No internet");
    #####:  825:            menu_item_warp_to(title_item);
        -:  826:        }
        -:  827:    }
        -:  828:
     3507:  829:    log_debug(MAIN_CTX, "End:  Callback\n");
        -:  830:
     3507:  831:    return 1;
        -:  832:
        -:  833:}
        -:  834:
       15:  835:int weather_lstnr(weather *weather) {
       15:  836:    if (weather) {
        -:  837:
       15:  838:        wthr.temp = weather->temp;
       15:  839:        wthr.weather_icon = my_copystr((const char *) weather->weather_icon);
       15:  840:        log_info(MAIN_CTX, "Received new weather: %.0f°C [%s]\n",weather->temp, weather->weather_icon);
        -:  841:
        -:  842:    }
        -:  843:
       15:  844:    return 1;
        -:  845:
        -:  846:}
        -:  847:
        1:  848:menu_ctrl *create_menu() {
        -:  849:
        1:  850:    char *font = get_config_value("font", DEFAULT_FONT);
        1:  851:    char *info_font = get_config_value("info_font", font);
        1:  852:    char *info_bg_image_path = get_config_value("info_bg_image_path", NULL);
        1:  853:    int font_size = get_config_value_int("font_size",DEFAULT_FONT_SIZE);
        1:  854:    int info_font_size = get_config_value_int("info_font_size",DEFAULT_INFO_FONT_SIZE);
        1:  855:    char *weather_font = get_config_value("weather_font", DEFAULT_FONT);
        1:  856:    int weather_font_size = get_config_value_int("weather_font_size", info_font_size);
        1:  857:    int temp_font_size = get_config_value_int("temperature_font_size", info_font_size);
        1:  858:    int time_font_size = get_config_value_int("time_font_size",info_font_size);
        1:  859:    int w = get_config_value_int("window_width",DEFAULT_WINDOW_WIDTH);
        1:  860:    int y_offset = get_config_value_int("y_offset",DEFAULT_Y_OFFSET);
        1:  861:    int x_offset = get_config_value_int("x_offset",DEFAULT_Y_OFFSET);
        1:  862:    double angle_offset = get_config_value_double("angle_offset", DEFAULT_ANGLE_OFFSET);
        1:  863:    int radius_labels = get_config_value_int("radius_labels", DEFAULT_LABEL_RADIUS);
        1:  864:    int radius_scales_start = get_config_value_int("radius_scales_start", DEFAULT_SCALES_RADIUS_START);
        1:  865:    int radius_scales_end = get_config_value_int("radius_scales_end", DEFAULT_SCALES_RADIUS_END);
        1:  866:    int draw_scales = get_config_value_int("draw_scales",1);
        1:  867:    int light_x = get_config_value_int("light_x", (int) w/2);
        1:  868:    int light_y = get_config_value_int("light_y", 100);
        1:  869:    int light_radius = get_config_value_int("light_radius", 300);
        1:  870:    int light_alpha = get_config_value_int("light_alpha", 0);
        1:  871:    char *light_img = get_config_value("light_image_path",NULL);
        1:  872:    int radio_radius_labels = get_config_value_int("radio_radius_labels", radius_labels);
        1:  873:    info_menu_item_seconds = get_config_value_int("info_menu_item_seconds",INFO_MENU_ITEM_SECONDS);
        1:  874:    hsv_style = get_config_value_int("hsv_style",0);
        -:  875:
        1:  876:    default_theme = get_config_theme ("Default");
        1:  877:    char *info_color = get_config_value_group("info_color", NULL, "Default");
        1:  878:    bluetooth_theme = get_config_theme("Bluetooth");
        1:  879:    spotify_theme = get_config_theme("Spotify");
        -:  880:
        1:  881:    menu_ctrl *ctrl = menu_ctrl_new(w, x_offset, y_offset, radius_labels, draw_scales, radius_scales_start, radius_scales_end, angle_offset, font, font_size, 0, &MENU_ACTION_LISTENER, &MENU_CALL_BACK);
        -:  882:
        1:  883:    if (ctrl) {
        -:  884:
        1:  885:        menu_ctrl_set_light(ctrl,light_x,light_y,light_radius,light_alpha);
        1:  886:        if (light_img) {
        1:  887:            menu_ctrl_set_light_img(ctrl,light_img);
        -:  888:        }
        -:  889:
        1:  890:        menu_ctrl_apply_theme (ctrl,default_theme);
        -:  891:
        1:  892:        ctrl->root[0]->current_id = 0;
        -:  893:
        1:  894:        info_menu = ctrl->root[0];
        1:  895:        if (info_color != NULL) {
        1:  896:            menu_set_colors(info_menu, html_to_color(info_color), html_to_color(info_color));
        -:  897:        }
        -:  898:
        1:  899:        if (info_bg_image_path) {
        1:  900:            menu_set_bg_image(info_menu, info_bg_image_path);
        -:  901:        }
        -:  902:
        1:  903:        info_menu->transient = 1;
        -:  904:
        1:  905:        time_t timer;
        1:  906:        time(&timer);
        1:  907:        struct tm *tm_info = localtime(&timer);
        1:  908:        last_tm_min = tm_info->tm_min;
        -:  909:
        1:  910:        char *buffer = malloc(25 * sizeof(char));
        1:  911:        strftime(buffer, 25, time_menu_item_format, tm_info);
        -:  912:
        1:  913:        time_item = menu_item_new(ctrl->root[0], buffer, NULL, OBJ_TYPE_TIME, info_font, time_font_size, NULL, NULL, -1);
        1:  914:        free(buffer);
        1:  915:        title_item = menu_item_new(ctrl->root[0], "VE 301", NULL, UNKNOWN_OBJECT_TYPE, info_font, info_font_size, NULL, NULL, -1);
        1:  916:        name_item = menu_item_new(ctrl->root[0], "VE 301", NULL, UNKNOWN_OBJECT_TYPE, info_font, info_font_size, NULL, NULL, -1);
        -:  917:
        1:  918:        const char *weather_api_key = get_config_value("weather_api_key", "");
        1:  919:        const char *weather_location = get_config_value("weather_location", "");
        1:  920:        const char *weather_units = get_config_value("weather_units", "metric");
        1:  921:        if (strlen(weather_api_key) > 0 && strlen(weather_location) > 0) {
        1:  922:            init_weather(120,weather_api_key,weather_location,weather_units);
        1:  923:            weather_item = menu_item_new(ctrl->root[0], " ", NULL, UNKNOWN_OBJECT_TYPE, weather_font, weather_font_size, NULL, font, font_size);
        1:  924:            temperature_item = menu_item_new(ctrl->root[0], "Weather", NULL, UNKNOWN_OBJECT_TYPE, info_font, temp_font_size, NULL, font, font_size);
        1:  925:            start_weather_thread(&weather_lstnr);
        -:  926:        } else {
    #####:  927:            weather_item = NULL;
        -:  928:        }
        -:  929:
        1:  930:        ctrl->active = NULL;
        -:  931:
        1:  932:        radio_menu = menu_new(ctrl, 3);
        1:  933:        radio_menu->segments_per_item = 1;
        1:  934:        radio_menu->n_o_items_on_scale = 4 * ctrl->n_o_items_on_scale;
        1:  935:        radio_menu->radius_labels = radio_radius_labels;
        -:  936:
        1:  937:        playlist *internet_radios = get_internet_radios();
        1:  938:        if (internet_radios != NULL) {
        -:  939:            Uint32 r = 0;
       15:  940:            for (r = 0; r < internet_radios->n_songs; r++) {
       14:  941:                song *s = internet_radios->songs[r];
       14:  942:                menu_item_new(radio_menu, s->title, s, OBJ_TYPE_SONG, NULL, -1, NULL, NULL, -1);
        -:  943:            }
        -:  944:        } else {
    #####:  945:            log_error(MAIN_CTX, "create_menu: playlist is NULL\n");
    #####:  946:            menu_item_new(radio_menu, "FEHLER", NULL, UNKNOWN_OBJECT_TYPE, NULL, -1, NULL, NULL, -1);
        -:  947:        }
        -:  948:
        1:  949:        lib_menu = menu_new(ctrl,1);
        1:  950:        album_menu = menu_new(ctrl,1);
        1:  951:        menu_add_sub_menu(lib_menu, "Alben", album_menu, NULL);
        1:  952:        nav_menu = menu_new_root(ctrl, 1);
        1:  953:        menu_add_sub_menu(nav_menu, "Radio", radio_menu, NULL);
        1:  954:        menu_add_sub_menu(nav_menu, "Bibliothek", lib_menu, NULL);
        -:  955:
        1:  956:        settings_menu = menu_new(ctrl,1);
        1:  957:        menu_item_new(settings_menu, "X Offset", NULL, OBJECT_TYPE_ACTION, NULL, -1, &item_action_x_offset, NULL, -1);
        -:  958:        //menu_item_new(settings_menu, "X Offset-", NULL, OBJECT_TYPE_ACTION, NULL, -1, &item_action_offset_left, NULL, -1);
        1:  959:        menu_item_new(settings_menu, "Y Offset", NULL, OBJECT_TYPE_ACTION, NULL, -1, &item_action_y_offset, NULL, -1);
        1:  960:        menu_item_new(settings_menu, "Label Radius", NULL, OBJECT_TYPE_ACTION, NULL, -1, &item_action_label_radius, NULL, -1);
        1:  961:        menu_item_new(settings_menu, "Einstellungen Speichern", NULL, OBJECT_TYPE_ACTION, NULL, -1, &item_action_store_config, NULL, -1);
        1:  962:        menu_add_sub_menu(nav_menu, "Einstellungen", settings_menu, NULL);
        -:  963:
        1:  964:        menu *themes_menu = menu_new(ctrl,1);
        1:  965:        menu_item_new(themes_menu, "Background", NULL, OBJECT_TYPE_ACTION, NULL, -1, &item_action_background_hue, NULL, -1);
        1:  966:        menu_item_new(themes_menu, "Default Foreground", NULL, OBJECT_TYPE_ACTION, NULL, -1, &item_action_default_hue, NULL, -1);
        1:  967:        menu_item_new(themes_menu, "Selected Foreground", NULL, OBJECT_TYPE_ACTION, NULL, -1, &item_action_selected_hue, NULL, -1);
        1:  968:        menu_item_new(themes_menu, "Active Foreground", NULL, OBJECT_TYPE_ACTION, NULL, -1, &item_action_active_hue, NULL, -1);
        -:  969:
        1:  970:        menu_add_sub_menu(settings_menu,"Theme", themes_menu, NULL);
        -:  971:
        1:  972:        root_dir_menu = menu_new(ctrl,1);
        1:  973:        menu_item *dir_menu_item = menu_add_sub_menu(nav_menu, "Verzeichnisse", root_dir_menu, item_action_update_directories_menu);
        1:  974:        dir_menu_item->object = "/";
        1:  975:        dir_menu_item->object_type = OBJ_TYPE_DIRECTORY;
        1:  976:        song_menu = menu_new(ctrl,1);
        -:  977:
        1:  978:        volume_menu = menu_new_root(ctrl,1);
        1:  979:        volume_menu->transient = 1;
        1:  980:        volume_menu->draw_only_active = 1;
        1:  981:        if (info_bg_image_path) {
        1:  982:            menu_set_bg_image(volume_menu, info_bg_image_path);
        -:  983:        }
        1:  984:        int volume = get_volume();
        1:  985:        volume_menu_item = menu_item_new(volume_menu,get_vol_label(volume),NULL,UNKNOWN_OBJECT_TYPE,info_font,info_font_size,NULL, NULL, -1);
        -:  986:
        -:  987:    }
        -:  988:
        1:  989:    if (font != DEFAULT_FONT) {
        1:  990:        free(font);
        -:  991:    }
        -:  992:
        1:  993:    return ctrl;
        -:  994:}
        -:  995:
    #####:  996:void sig_handler(int signo) {
    #####:  997:    switch(signo) {
    #####:  998:        case SIGHUP:
    #####:  999:            log_info(MAIN_CTX, "SIGHUP received. Rereading config\n");
    #####: 1000:            init_config_file("ve301");
    #####: 1001:            if (default_theme) {
    #####: 1002:                free_theme(default_theme);
        -: 1003:            }
    #####: 1004:            default_theme = get_config_theme ("Default");
    #####: 1005:            if (bluetooth_theme) {
    #####: 1006:                free_theme(bluetooth_theme);
        -: 1007:            }
    #####: 1008:            bluetooth_theme = get_config_theme ("Bluetooth");
    #####: 1009:            if (spotify_theme) {
    #####: 1010:                free_theme(spotify_theme);
        -: 1011:            }
    #####: 1012:            spotify_theme = get_config_theme ("Spotify");
        -: 1013:
    #####: 1014:            int y_offset = get_config_value_int("y_offset",DEFAULT_Y_OFFSET);
    #####: 1015:            int x_offset = get_config_value_int("x_offset",DEFAULT_Y_OFFSET);
    #####: 1016:            double angle_offset = get_config_value_double("angle_offset", DEFAULT_ANGLE_OFFSET);
    #####: 1017:            int radius_labels = get_config_value_int("radius_labels", DEFAULT_LABEL_RADIUS);
    #####: 1018:            int radius_scales_start = get_config_value_int("radius_scales_start", DEFAULT_SCALES_RADIUS_START);
    #####: 1019:            int radius_scales_end = get_config_value_int("radius_scales_end", DEFAULT_SCALES_RADIUS_START);
        -: 1020:
    #####: 1021:            ctrl->y_offset = y_offset;
    #####: 1022:            ctrl->x_offset = x_offset;
    #####: 1023:            ctrl->angle_offset = angle_offset;
        -: 1024:
    #####: 1025:            menu_ctrl_set_radii(ctrl,radius_labels,radius_scales_start,radius_scales_end);
        -: 1026:
    #####: 1027:            menu_ctrl_apply_theme (ctrl,default_theme);
        -: 1028:
    #####: 1029:            break;
    #####: 1030:        default:
    #####: 1031:            log_info(MAIN_CTX, "Bye with signal %d\n", signo);
    #####: 1032:            menu_ctrl_quit(ctrl);
    #####: 1033:            base_close();
    #####: 1034:            exit(0);
    #####: 1035:            break;
        -: 1036:    }
    #####: 1037:}
        -: 1038:
        1: 1039:int main(int argc, char **argv) {
        -: 1040:
        1: 1041:    base_init("ve301", stderr, IR_LOG_LEVEL_DEBUG);
        -: 1042:
        1: 1043:    log_info(MAIN_CTX, "Setting signals\n");
        1: 1044:    signal(SIGTERM, sig_handler);
        1: 1045:    signal(SIGINT, sig_handler);
        1: 1046:    signal(SIGHUP, sig_handler);
        -: 1047:
        1: 1048:    bt_init();
        -: 1049:
        1: 1050:    log_info(MAIN_CTX, "Creating menu\n");
        1: 1051:    ctrl = create_menu();
        -: 1052:
        1: 1053:    log_info(MAIN_CTX, "Entering main loop\n");
        1: 1054:    if (ctrl) {
        1: 1055:        menu_ctrl_loop(ctrl);
        1: 1056:        audio_disconnect();
        1: 1057:        base_close();
        1: 1058:        return EXIT_SUCCESS;
        -: 1059:    } else {
    #####: 1060:        base_close();
    #####: 1061:        return EXIT_FAILURE;
        -: 1062:    }
        -: 1063:
        -: 1064:}
        -: 1065:
