        -:    0:Source:../src/menu.c
        -:    0:Graph:menu.gcno
        -:    0:Data:menu.gcda
        -:    0:Runs:1
        -:    0:Source is newer than graph
        -:    1:/*
        -:    2: * Copyright 2022 LJunkie
        -:    3: * https://github.com/ljunkie0/ve301
        -:    4: *
        -:    5: * This program is free software; you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation; either version 2 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License along
        -:   16: * with this program; if not, write to the Free Software Foundation, Inc.,
        -:   17: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
        -:   18: */
        -:   19:
        -:   20:#include <stdlib.h>
        -:   21:#include <math.h>
        -:   22:#include <time.h>
        -:   23:#include <signal.h>
        -:   24:#include <execinfo.h>
        -:   25:#include <SDL2/SDL2_rotozoom.h>
        -:   26:#include <unistd.h>
        -:   27:#include "menu.h"
        -:   28:#include "base.h"
        -:   29:#include "sdl_util.h"
        -:   30:
        -:   31:#ifdef RASPBERRY
        -:   32:#include"rotaryencoder.h"
        -:   33:#endif
        -:   34:#if SDL_BYTEORDER == SDL_BIG_ENDIAN
        -:   35:#define RMASK 0xff000000
        -:   36:#define GMASK 0x00ff0000
        -:   37:#define BMASK 0x0000ff00
        -:   38:#define AMASK 0x000000ff
        -:   39:#else
        -:   40:#define RMASK 0x000000ff
        -:   41:#define GMASK 0x0000ff00
        -:   42:#define BMASK 0x00ff0000
        -:   43:#define AMASK 0xff000000
        -:   44:#endif
        -:   45:
        -:   46:#define get_kerning TTF_GetFontKerningSizeGlyphs
        -:   47:#define DEFAULT_SDL_PIXELFORMAT SDL_PIXELFORMAT_RGBA32
        -:   48:
        -:   49:#define MAX_LABEL_LENGTH 25
        -:   50:#define FONT_DEFAULT "/usr/share/fonts/truetype/freefont/FreeSans.ttf"
        -:   51:#define BOLD_FONT_DEFAULT "/usr/share/fonts/truetype/freefont/FreeSansBold.ttf"
        -:   52:
        -:   53:#define Y_OFFSET 35
        -:   54:
        -:   55:#define M_2_X_PI 6.28318530718
        -:   56:#ifndef M_PI_2
        -:   57:#define M_PI_2 1.57079632679489661923132
        -:   58:#endif
        -:   59:
        -:   60:// the number of possible angles. Don't know yet
        -:   61:#define N_ANGLES 180
        -:   62:
        -:   63:#define VISIBLE_ANGLE 72.0
        -:   64:
        -:   65:#define USE_UNICODE
        -:   66:
        -:   67:static double *cosinuses = NULL;
        -:   68:static double *sinuses = NULL;
        -:   69:static double *square_roots = NULL;
        -:   70:
        -:   71:static SDL_Color black = { 0, 0, 0, 255 };
        -:   72:static SDL_Color white = { 255, 255, 255, 255 };
        -:   73:
        -:   74:static int current_hour = -1;
        -:   75:
        -:   76:/* For FPS measuring */
        -:   77:static Uint32 render_start_ticks;
        -:   78:
        -:   79:/**
        -:   80:* Menu item state:
        -:   81:* SELECTED: Currently the one under the indicator
        -:   82:* ACTIVE: the radio station e.g. that is currently played
        -:   83:* DEFAULT: all others
        -:   84:**/
        -:   85:typedef enum {
        -:   86:    ACTIVE, SELECTED, DEFAULT
        -:   87:} menu_item_state;
        -:   88:
        -:   89:typedef struct double_rect {
        -:   90:    double w,h,x,y;
        -:   91:} double_rect;
        -:   92:
        -:   93:/**
        -:   94:* For bump mapping
        -:   95:**/
        -:   96:typedef struct normal_vector {
        -:   97:    double x;
        -:   98:    double y;
        -:   99:} normal_vector;
        -:  100:
        -:  101:/**
        -:  102:* Represents one glyph
        -:  103:**/
        -:  104:typedef struct glyph_obj {
        -:  105:    SDL_Texture *texture;
        -:  106:    SDL_Surface *surface;
        -:  107:    SDL_Texture *bumpmap_overlay;
        -:  108:    SDL_Texture **bumpmap_textures;
        -:  109:    Uint32 *light_pixels;
        -:  110:    int pitch;
        -:  111:    SDL_Color *colors;
        -:  112:    normal_vector *normals;
        -:  113:    int advance;
        -:  114:    int minx;
        -:  115:    int maxx;
        -:  116:    int miny;
        -:  117:    int maxy;
        -:  118:    SDL_Rect *dst_rect;
        -:  119:    SDL_Point *rot_center;
        -:  120:    double current_angle;
        -:  121:    double shadow_dx;
        -:  122:    double shadow_dy;
        -:  123:} glyph_obj;
        -:  124:
        -:  125:/**
        -:  126:* Represents one text (menu item label)
        -:  127:**/
        -:  128:typedef struct text_obj {
        -:  129:    int n_glyphs; // The number of characters
        -:  130:    int n_glyphs_2nd_line; // The number of characters on the seconds line if there is any
        -:  131:    glyph_obj **glyphs_objs;
        -:  132:    glyph_obj **glyphs_objs_2nd_line;
        -:  133:    int width;
        -:  134:    int width_2nd_line;
        -:  135:    int height;
        -:  136:    int height_2nd_line;
        -:  137:} text_obj;
        -:  138:
        -:  139:void menu_turn_left(menu *m);
        -:  140:void menu_turn_right(menu *m);
        -:  141:void menu_fade_out(menu *menu_frm, menu *menu_to);
        -:  142:int menu_ctrl_draw_scale(menu_ctrl *ctrl, double xc, double yc, double r, double R, double angle, unsigned char alpha, int lines);
        -:  143:int menu_ctrl_clear(menu_ctrl *ctrl, double angle);
        -:  144:int menu_ctrl_process_events(menu_ctrl *ctrl);
        -:  145:int menu_draw(menu *m, int clear, int render);
        -:  146:int menu_ctrl_apply_light(menu_ctrl *ctrl);
        -:  147:
        -:  148:/**
        -:  149: * Creates a texture that is blended over the background to create
        -:  150: * the illusion of a light
        -:  151: * @brief new_light_texture
        -:  152: * @param renderer The SDL renderer
        -:  153: * @param w width of the texture
        -:  154: * @param h height of the texture
        -:  155: * @param light_x x position of the lightt
        -:  156: * @param light_y y position of the light
        -:  157: * @param radius radius of the light
        -:  158: * @param alpha alpha value of the texture
        -:  159: * @return The SDL_Texture representing the light
        -:  160: */
        1:  161:SDL_Texture *new_light_texture(SDL_Renderer *renderer, int w, int h, int light_x, int light_y, int radius, int alpha) {
        -:  162:
        1:  163:    SDL_Texture *light_texture = SDL_CreateTexture(renderer,DEFAULT_SDL_PIXELFORMAT,SDL_TEXTUREACCESS_STATIC,w,h);
        1:  164:    SDL_SetTextureBlendMode(light_texture,SDL_BLENDMODE_MUL);
        1:  165:    SDL_PixelFormat *format = SDL_AllocFormat(DEFAULT_SDL_PIXELFORMAT);
        -:  166:
        1:  167:    Uint32 pixels[w*h];
        -:  168:
      521:  169:    for (int y = 0; y < h; y++) {
      520:  170:        int o = w * y;
      520:  171:        int sq_y = (y - light_y)*(y - light_y);
   416520:  172:        for (int x = 0; x < w; x++) {
        -:  173:
   416000:  174:            double d = SDL_sqrt((x - light_x)*(x - light_x) + sq_y);
   416000:  175:            double l = 255.0 - 255.0 * d / radius;
   416000:  176:            if (l < 0.0) l = 0.0;
  416000*:  177:            if (l > 255.0) l = 255.0;
        -:  178:
   416000:  179:            Uint32 pixel = alpha;
   416000:  180:            if (l >= 0.0) {
   416000:  181:                pixel = SDL_MapRGBA(format,l,l,l,alpha);
        -:  182:            }
   416000:  183:            pixels[x+o] = pixel;
        -:  184:
        -:  185:        }
        -:  186:    }
        -:  187:
        1:  188:    SDL_FreeFormat(format);
        1:  189:    SDL_UpdateTexture(light_texture,NULL,pixels,4*w);
        -:  190:
        1:  191:    return light_texture;
        -:  192:}
        -:  193:
        1:  194:SDL_Texture *load_light_texture(SDL_Renderer *renderer, char *path) {
        1:  195:    return IMG_LoadTexture(renderer,path);
        -:  196:}
        -:  197:
      741:  198:void glyph_obj_free(glyph_obj *obj) {
      741:  199:    log_debug(MENU_CTX, "glyph_obj_free (%p)\n", obj);
      741:  200:    if (obj) {
        -:  201:
      741:  202:        if (obj->colors) {
      741:  203:            free(obj->colors);
        -:  204:        }
        -:  205:
      741:  206:        if (obj->normals) {
      741:  207:            free(obj->normals);
        -:  208:        }
        -:  209:
      741:  210:        if (obj->surface) {
      741:  211:            SDL_FreeSurface(obj->surface);
        -:  212:        }
        -:  213:
      741:  214:        if (obj->texture) {
      741:  215:            SDL_DestroyTexture(obj->texture);
        -:  216:        }
        -:  217:
      741:  218:        if (obj->bumpmap_overlay) {
      288:  219:            SDL_DestroyTexture(obj->bumpmap_overlay);
        -:  220:        }
        -:  221:
      741:  222:        if (obj->rot_center) {
      741:  223:            free(obj->rot_center);
        -:  224:        }
        -:  225:
      741:  226:        if (obj->dst_rect) {
      741:  227:            free(obj->dst_rect);
        -:  228:        }
        -:  229:
      741:  230:        if (obj->bumpmap_textures) {
    #####:  231:            for (int a = 0; a < N_ANGLES; a++) {
    #####:  232:                if (obj->bumpmap_textures[a]) {
    #####:  233:                    SDL_DestroyTexture(obj->bumpmap_textures[a]);
        -:  234:                }
        -:  235:                //free(obj->lights);
        -:  236:            }
        -:  237:        }
        -:  238:
      741:  239:        free(obj);
        -:  240:
        -:  241:    }
      741:  242:}
        -:  243:
     1545:  244:void glyph_obj_update_cnt_rad(glyph_obj *glyph_o, SDL_Point center, int radius, int light_x, int light_y) {
        -:  245:
     1545:  246:    glyph_o->dst_rect->x = center.x - 0.5 * glyph_o->dst_rect->w;
     1545:  247:    glyph_o->dst_rect->y = center.y - radius - 0.5 * glyph_o->dst_rect->h;
     1545:  248:    glyph_o->rot_center->x = 0.5 * glyph_o->dst_rect->w;
     1545:  249:    glyph_o->rot_center->y = radius + 0.5 * glyph_o->dst_rect->h;
        -:  250:
     1545:  251:}
        -:  252:
     1545:  253:glyph_obj *glyph_obj_new(SDL_Renderer *renderer, uint16_t c, TTF_Font *font, SDL_Color fg, SDL_Point center, int radius, int light_x, int light_y) {
        -:  254:
     1545:  255:    glyph_obj *glyph_o = calloc(1,sizeof(glyph_obj));
        -:  256:
     1545:  257:    glyph_o->surface = TTF_RenderGlyph_Blended(font,c,fg);
     1545:  258:    if (glyph_o->surface == NULL) {
    #####:  259:        log_error(MENU_CTX, "Could not render glyph %c: %s\n", c, TTF_GetError());
    #####:  260:        return NULL;
        -:  261:    }
        -:  262:
     1545:  263:    glyph_o->current_angle = -2000.0;
        -:  264:
     1545:  265:    glyph_o->normals = calloc(glyph_o->surface->w * glyph_o->surface->h , sizeof(normal_vector));
     1545:  266:    glyph_o->colors = calloc(glyph_o->surface->w * glyph_o->surface->h , sizeof(SDL_Color));
        -:  267:
     1545:  268:    Uint32 *pixels = (Uint32 *) glyph_o->surface->pixels;
        -:  269:
     1545:  270:    int bpp = glyph_o->surface->format->BytesPerPixel;
     1545:  271:    int pitch = glyph_o->surface->pitch / bpp;
        -:  272:
   144327:  273:    for (int y = 0; y < glyph_o->surface->h; y++) {
   142782:  274:        int o = glyph_o->surface->w*y;
   142782:  275:        int p = pitch*y;
   142782:  276:        int pop = pitch * (y-1);
   142782:  277:        int pon = pitch * (y+1);
  5839101:  278:        for (int x = 0; x < glyph_o->surface->w; x++) {
  5696319:  279:            Uint32 pixel = pixels[p + x];
  5696319:  280:            SDL_Color color;
  5696319:  281:            SDL_GetRGBA(pixel,glyph_o->surface->format,&(color.r),&(color.g),&(color.b),&(color.a));
        -:  282:
  5696319:  283:            glyph_o->colors[o + x] = color;
        -:  284:
  5696319:  285:            double dx = 0.0;
  5696319:  286:            double dy = 0.0;
        -:  287:
  5696319:  288:            if (color.a) {
        -:  289:
  1036629:  290:                Uint8 r,g,b; // actually only needed for the call to SDL_GetRGBA
        -:  291:
  1036629:  292:                Uint8 pax = 0;
  1036629:  293:                if (x > 0) {
  1035747:  294:                    Uint32 p_x_pixel = pixels[p + (x - 1)];
  1035747:  295:                    SDL_GetRGBA(p_x_pixel,glyph_o->surface->format,&r,&g,&b,&pax);
        -:  296:                }
        -:  297:
  1036629:  298:                Uint8 pay;
  1036629:  299:                if (y > 0) {
  1036629:  300:                    Uint32 p_y_pixel = pixels[pop + x];
  1036629:  301:                    SDL_GetRGBA(p_y_pixel,glyph_o->surface->format,&r,&g,&b,&pay);
        -:  302:                }
        -:  303:
  1036629:  304:                Uint8 nax;
  1036629:  305:                if (x < glyph_o->surface->w) {
  1036629:  306:                    Uint32 n_x_pixel = pixels[p + (x + 1)];
  1036629:  307:                    SDL_GetRGBA(n_x_pixel,glyph_o->surface->format,&r,&g,&b,&nax);
        -:  308:                }
        -:  309:
  1036629:  310:                Uint8 nay;
  1036629:  311:                if (y < glyph_o->surface->h) {
  1036629:  312:                    Uint32 n_y_pixel = pixels[pon + x];
  1036629:  313:                    SDL_GetRGBA(n_y_pixel,glyph_o->surface->format,&r,&g,&b,&nay);
        -:  314:                }
        -:  315:
  1036629:  316:                dx = (nax - pax);
  1036629:  317:                dy = (nay - pay);
        -:  318:
  1036629:  319:                if (dx != 0 || dy != 0) {
   584559:  320:                    double inv_dn = Q_rsqrt(dx * dx + dy * dy);
   584559:  321:                    dx = dx * inv_dn;
   584559:  322:                    dy = dy * inv_dn;
        -:  323:                } else {
        -:  324:                    dx = 0.0;
        -:  325:                    dy = 0.0;
        -:  326:                }
        -:  327:
        -:  328:            }
        -:  329:
  5696319:  330:            normal_vector df;
  5696319:  331:            df.x = dx;
  5696319:  332:            df.y = dy;
  5696319:  333:            glyph_o->normals[o + x] = df;
        -:  334:
        -:  335:        }
        -:  336:    }
        -:  337:
     1545:  338:    normal_vector df;
     1545:  339:    df.x = 0;
     1545:  340:    df.y = 0;
     1545:  341:    SDL_Color transparent;
     1545:  342:    transparent.r = 0;
     1545:  343:    transparent.g = 0;
     1545:  344:    transparent.b = 0;
     1545:  345:    transparent.a = 0;
        -:  346:
     1545:  347:    glyph_o->normals[0] = df;
     1545:  348:    glyph_o->colors[0] = transparent;
        -:  349:
   142782:  350:    for (int y = 1; y < glyph_o->surface->h; y++) {
   141237:  351:        glyph_o->normals[glyph_o->surface->w * y] = df;
   141237:  352:        glyph_o->normals[glyph_o->surface->w * y - 1] = df;
   141237:  353:        glyph_o->colors[glyph_o->surface->w * y] = transparent;
   141237:  354:        glyph_o->colors[glyph_o->surface->w * y - 1] = transparent;
        -:  355:    }
        -:  356:
    55731:  357:    for (int x = 0; x < glyph_o->surface->w; x++) {
    54186:  358:        glyph_o->normals[x] = df;
    54186:  359:        glyph_o->normals[glyph_o->surface->w * (glyph_o->surface->h-1) + x] = df;
    54186:  360:        glyph_o->colors[x] = transparent;
    54186:  361:        glyph_o->colors[glyph_o->surface->w * (glyph_o->surface->h-1) + x] = transparent;
        -:  362:    }
        -:  363:
     1545:  364:    glyph_o->bumpmap_overlay = NULL;
        -:  365:
     1545:  366:    glyph_o->texture = SDL_CreateTextureFromSurface(renderer,glyph_o->surface);
     1545:  367:    if (!glyph_o->texture) {
    #####:  368:        log_error(MENU_CTX, "Could not generate texture from surface: %s\n", SDL_GetError());
        -:  369:    }
     1545:  370:    SDL_SetTextureBlendMode(glyph_o->texture,SDL_BLENDMODE_BLEND);
        -:  371:
     1545:  372:    Uint32 format;
     1545:  373:    int access;
     1545:  374:    SDL_Rect *dst = malloc(sizeof(SDL_Rect));
     1545:  375:    SDL_QueryTexture(glyph_o->texture,&format,&access,&(dst->w),&(dst->h));
     1545:  376:    glyph_o->dst_rect = dst;
        -:  377:
     1545:  378:    SDL_Point *rot_center = malloc(sizeof(SDL_Point));
     1545:  379:    glyph_o->rot_center = rot_center;
        -:  380:
     1545:  381:    glyph_obj_update_cnt_rad(glyph_o,center,radius, light_x, light_y);
        -:  382:
     1545:  383:    int minx = 0,maxx = 0,miny = 0,maxy = 0,advance = 0;
     1545:  384:    TTF_GlyphMetrics(font,c,&minx,&maxx,&miny,&maxy,&advance);
     1545:  385:    glyph_o->minx = minx;
     1545:  386:    glyph_o->maxx = maxx;
     1545:  387:    glyph_o->miny = miny;
     1545:  388:    glyph_o->maxy = maxy;
     1545:  389:    glyph_o->advance = advance;
        -:  390:
     1545:  391:    return glyph_o;
        -:  392:
        -:  393:}
        -:  394:
     3891:  395:void glyph_obj_update_bumpmap_texture(SDL_Renderer *renderer, glyph_obj *glyph_o, double center_x, double center_y, int angle, double l_x, double l_y) {
     3891:  396:
     3891:  397:    Uint32 *bumpmap_pixels;
     3891:  398:    int pitch;
        -:  399:
     3891:  400:    if (!glyph_o->bumpmap_overlay) {
      552:  401:        glyph_o->bumpmap_overlay = SDL_CreateTexture(renderer,DEFAULT_SDL_PIXELFORMAT,SDL_TEXTUREACCESS_STREAMING,glyph_o->surface->w,glyph_o->surface->h);
      552:  402:        SDL_SetTextureBlendMode(glyph_o->bumpmap_overlay,SDL_BLENDMODE_BLEND);
        -:  403:    }
        -:  404:
     3891:  405:    SDL_LockTexture(glyph_o->bumpmap_overlay,NULL,(void **) &bumpmap_pixels, &pitch);
        -:  406:
     3891:  407:    if (cosinuses == NULL) {
        1:  408:        cosinuses = malloc(10000*sizeof(double));
        1:  409:        sinuses = malloc(10000*sizeof(double));
        1:  410:        square_roots = malloc(10000*sizeof(double));
    10001:  411:        for (int i = 0; i < 10000; i++) {
    10000:  412:            cosinuses[i] = 2.0;
    10000:  413:            sinuses[i] = 2.0;
    10000:  414:            square_roots[i] = -100000.0;
        -:  415:        }
        -:  416:    }
        -:  417:
     3891:  418:    int idx = (int) (10.0 * (angle + 360.0));
     3891:  419:    double c = cosinuses[idx];
     3891:  420:    double s = sinuses[idx];
     3891:  421:    if (c > 1.0) {
      143:  422:        double angle_rad = M_PI * angle / 180.0;
      143:  423:        c = cosf(angle_rad);
      143:  424:        cosinuses[idx] = c;
      143:  425:        s = sinf(angle_rad);
      143:  426:        sinuses[idx] = s;
        -:  427:    }
        -:  428:
     3891:  429:    SDL_PixelFormat *format = glyph_o->surface->format;
     3891:  430:    Uint32 transparent = 0;
        -:  431:
        -:  432:    /*
        -:  433:     * Update shadow offset direction
        -:  434:     */
     3891:  435:    double x = glyph_o->dst_rect->x+0.5*glyph_o->dst_rect->w-center_x;
     3891:  436:    double y = glyph_o->dst_rect->y+0.5*glyph_o->dst_rect->h-center_y;
     3891:  437:    double c_x_rot = c * x - s * y + center_x;
     3891:  438:    double c_y_rot = s * x + c * y + center_y;
        -:  439:
     3891:  440:    double light_x = c_x_rot - l_x;
     3891:  441:    double light_y = c_y_rot - l_y;
     3891:  442:    double light_d = (double) Q_rsqrt((float)(light_x*light_x + light_y*light_y));
        -:  443:
     3891:  444:    glyph_o->shadow_dx = light_d * light_x;
     3891:  445:    glyph_o->shadow_dy = light_d * light_y;
        -:  446:
        -:  447:    /**
        -:  448:     * See below. Usually, the distance to the light source should be taken for each pixel (to be adjusted)
        -:  449:     * in the glyph. For performance, only take the distance from the top left pixel
        -:  450:     */
     3891:  451:    double x_rot = c * (glyph_o->dst_rect->x-center_x) - s * (glyph_o->dst_rect->y - center_y) + center_x;
     3891:  452:    double y_rot = s * (glyph_o->dst_rect->x-center_x) + c * (glyph_o->dst_rect->y - center_y) + center_y;
        -:  453:
     3891:  454:    light_x = x_rot - l_x;
     3891:  455:    light_y = y_rot - l_y;
        -:  456:
     3891:  457:    double inv_light_d = Q_rsqrt((float)(light_x*light_x + light_y*light_y));
        -:  458:
     3891:  459:    light_x = inv_light_d * light_x;
     3891:  460:    light_y = inv_light_d * light_y;
        -:  461:
        -:  462:    /**
        -:  463:     * <<
        -:  464:     */
        -:  465:
   321083:  466:    for (int y = 0; y < glyph_o->surface->h; y++) {
        -:  467:
   317192:  468:        int o = pitch * y / 4;
        -:  469:
 11773659:  470:        for (int x = 0; x < glyph_o->surface->w; x++) {
        -:  471:
 11456467:  472:            SDL_Color color = glyph_o->colors[o+x];
        -:  473:
 11456467:  474:            if (color.a > 1) {
        -:  475:
  2248538:  476:                Uint8 r = color.r,g = color.g,b = color.b,a = color.a;
  2248538:  477:                normal_vector df = glyph_o->normals[o+x];
        -:  478:
  2248538:  479:                if (df.x != 0 || df.y != 0) {
        -:  480:
        -:  481:                    // angle to light
  1246268:  482:                    double dx_rot = c * df.x - s * df.y;
  1246268:  483:                    double dy_rot = s * df.x + c * df.y;
        -:  484:
  1246268:  485:                    double light = light_x * dx_rot + light_y * dy_rot;
        -:  486:
  1246268:  487:                    if (light >= 0.0) {
   621372:  488:                        r = r + (255.0 - r) * light;
   621372:  489:                        g = g + (255.0 - g) * light;
   621372:  490:                        b = b + (255.0 - b) * light;
        -:  491:                    } else {
   624896:  492:                        r = r * (1.0+light);
   624896:  493:                        g = g * (1.0+light);
   624896:  494:                        b = b * (1.0+light);
        -:  495:                    }
        -:  496:
        -:  497:                }
        -:  498:
        -:  499:                /**
        -:  500:                 * Have to switch B and R, i don't know why
        -:  501:                 */
  2248538:  502:                Uint32 lght = (b << format->Rshift) | (g << format->Gshift) | (r << format->Bshift) | (a << format->Ashift & format->Amask);
  2248538:  503:                bumpmap_pixels[o + x] = lght;
        -:  504:
        -:  505:            } else {
  9207929:  506:                bumpmap_pixels[o + x] = transparent;
        -:  507:            }
        -:  508:        }
        -:  509:
        -:  510:    }
        -:  511:
     3891:  512:    SDL_UnlockTexture(glyph_o->bumpmap_overlay);
        -:  513:
     3891:  514:}
        -:  515:
        -:  516:
       81:  517:void text_obj_free(text_obj *obj) {
       81:  518:    if (obj) {
       81:  519:        if (obj->glyphs_objs) {
      822:  520:            for (int g = 0; g < obj->n_glyphs; g++) {
      741:  521:                glyph_obj_free(obj->glyphs_objs[g]);
        -:  522:            }
       81:  523:            free(obj->glyphs_objs);
        -:  524:        }
        -:  525:
       81:  526:        if (obj->glyphs_objs_2nd_line) {
    #####:  527:            for (int g = 0; g < obj->n_glyphs_2nd_line; g++) {
    #####:  528:                glyph_obj_free(obj->glyphs_objs_2nd_line[g]);
        -:  529:            }
    #####:  530:            free(obj->glyphs_objs_2nd_line);
        -:  531:        }
        -:  532:
       81:  533:        free(obj);
        -:  534:
        -:  535:    }
       81:  536:}
        -:  537:
    #####:  538:void text_obj_update_cnt_rad(text_obj *obj, SDL_Point center, int radius, int line, int n_lines, int light_x, int light_y) {
    #####:  539:    if (obj) {
        -:  540:
    #####:  541:        if (obj->n_glyphs_2nd_line > 0) {
    #####:  542:            radius = radius + obj->height * 0.5;
        -:  543:        }
        -:  544:
    #####:  545:        radius = radius + 0.8 * obj->height * (line + 0.5 * (n_lines-1));
        -:  546:
    #####:  547:        if (obj->glyphs_objs) {
    #####:  548:            for (int g = 0; g < obj->n_glyphs; g++) {
    #####:  549:                glyph_obj_update_cnt_rad(obj->glyphs_objs[g], center, radius, light_x, light_y);
        -:  550:            }
        -:  551:        }
        -:  552:
    #####:  553:        int radius_new = radius - obj->height;
        -:  554:
    #####:  555:        if (obj->glyphs_objs_2nd_line) {
    #####:  556:            for (int g = 0; g < obj->n_glyphs_2nd_line; g++) {
    #####:  557:                glyph_obj_update_cnt_rad(obj->glyphs_objs_2nd_line[g], center, radius_new, light_x, light_y);
        -:  558:            }
        -:  559:        }
        -:  560:    }
    #####:  561:}
        -:  562:
        -:  563:
      162:  564:text_obj *text_obj_new(SDL_Renderer *renderer, char *txt, TTF_Font *font, TTF_Font *font_2nd_line, SDL_Color fg, SDL_Point center, int radius, int line, int n_lines, int light_x, int light_y) {
        -:  565:
      162:  566:    if (txt) {
      162:  567:        Uint32 unicode_length = MAX_LABEL_LENGTH;
      162:  568:        Uint16 *unicode_text_2nd_line = NULL;
      162:  569:        Uint32 unicode_length_second_line = MAX_LABEL_LENGTH;
      162:  570:        Uint16 *unicode_text = NULL;
      162:  571:        unicode_text = to_unicode(txt,&unicode_length,&unicode_text_2nd_line,&unicode_length_second_line);
        -:  572:
      162:  573:        if (!unicode_text) {
        -:  574:            return NULL;
        -:  575:        }
        -:  576:
      162:  577:        text_obj *t = malloc(sizeof(text_obj));
      162:  578:        t->n_glyphs = unicode_length;
      162:  579:        t->glyphs_objs = malloc(unicode_length * sizeof(glyph_obj *));
      162:  580:        log_debug(MENU_CTX, "Rendering surface for %s\n",unicode_text);
      162:  581:        SDL_Surface *text_surface = TTF_RenderUNICODE_Blended(font,unicode_text,fg);
        -:  582:
      162:  583:        if (text_surface == NULL) {
    #####:  584:            log_error(MENU_CTX, "Could not create glyph surface for %s: %s\n", txt, TTF_GetError());
    #####:  585:            return NULL;
        -:  586:        }
        -:  587:
      162:  588:        t->width = text_surface->w;
      162:  589:        t->height = text_surface->h;
        -:  590:
     162*:  591:        if (unicode_length_second_line > 0 && unicode_text_2nd_line != NULL) {
    #####:  592:            radius = radius + text_surface->h * 0.5;
        -:  593:        }
        -:  594:
      162:  595:        radius = radius + 0.8 * text_surface->h * (line + 0.5 * (n_lines-1));
        -:  596:
      162:  597:        SDL_FreeSurface(text_surface);
        -:  598:
      162:  599:        unsigned int i = 0;
     1869:  600:        for (i = 0; i < unicode_length; i++) {
     1545:  601:            glyph_obj *glyph_o = glyph_obj_new(renderer,unicode_text[i],font,fg,center,radius, light_x, light_y);
     1545:  602:            if (!glyph_o) {
    #####:  603:                log_error(MENU_CTX, "Could not create glyph object for %c\n", unicode_text[i]);
    #####:  604:                return NULL;
        -:  605:            }
     1545:  606:            t->glyphs_objs[i] = glyph_o;
        -:  607:        }
        -:  608:
      162:  609:        t->glyphs_objs_2nd_line = NULL;
      162:  610:        t->n_glyphs_2nd_line = unicode_length_second_line;
     162*:  611:        if (unicode_length_second_line > 0 && unicode_text_2nd_line != NULL) {
    #####:  612:            t->n_glyphs_2nd_line = unicode_length_second_line;
    #####:  613:            t->glyphs_objs_2nd_line = malloc(unicode_length_second_line * sizeof(glyph_obj *));
        -:  614:
    #####:  615:            text_surface = TTF_RenderUNICODE_Blended(font_2nd_line,unicode_text_2nd_line,fg);
    #####:  616:            if (text_surface == NULL) {
    #####:  617:                log_error(MENU_CTX, "Could not create glyph surface for %s: %s\n", txt, TTF_GetError());
    #####:  618:                return NULL;
        -:  619:            }
        -:  620:
    #####:  621:            t->width_2nd_line = text_surface->w;
    #####:  622:            t->height_2nd_line = text_surface->h;
    #####:  623:            SDL_FreeSurface(text_surface);
        -:  624:
    #####:  625:            unsigned int i = 0;
    #####:  626:            int radius_new = radius - text_surface->h;
    #####:  627:            for (i = 0; i < unicode_length_second_line; i++) {
    #####:  628:                t->glyphs_objs_2nd_line[i] = glyph_obj_new(renderer,unicode_text_2nd_line[i],font_2nd_line,fg,center,radius_new, light_x, light_y);
        -:  629:            }
        -:  630:        }
        -:  631:
      162:  632:        free(unicode_text);
      162:  633:        if (unicode_text_2nd_line) {
    #####:  634:            free(unicode_text_2nd_line);
        -:  635:        }
        -:  636:
      162:  637:        return t;
        -:  638:
        -:  639:    }
        -:  640:
        -:  641:    return NULL;
        -:  642:
        -:  643:}
        -:  644:
        -:  645:
     1799:  646:void text_obj_draw(SDL_Renderer *renderer, SDL_Texture *target, text_obj *label, int radius, int center_x, int center_y, double angle, int line, double light_x, double light_y, int font_bumpmap, int shadow_offset, int shadow_alpha) {
     1799:  647:    double circumference = M_2_X_PI * radius;
     1799:  648:    double advance = - 0.5 * label->width;
     1799:  649:    log_config(MENU_CTX,"text_obj_draw: angle: %f, radius: %d, circumference: %f, advance: %f\n", angle, radius, circumference, advance);
     1799:  650:    if (radius == 0) {
      108:  651:        log_config(MENU_CTX,"text_obj_draw: radius = 0, returning\n");
      108:  652:        return;
        -:  653:    }
        -:  654:
     1691:  655:    if (target != NULL) {
    #####:  656:        SDL_SetRenderTarget(renderer,target);
        -:  657:    }
        -:  658:
        -:  659:    int c;
    17471:  660:    for (c = 0; c < label->n_glyphs; c++) {
    15780:  661:        glyph_obj *glyph_obj = label->glyphs_objs[c];
    15780:  662:        double a = angle + 360.0 * (advance + 0.5 * glyph_obj->dst_rect->w)/circumference;
        -:  663:
    15780:  664:        if (a >= -VISIBLE_ANGLE && a <= VISIBLE_ANGLE) {
        -:  665:
     4522:  666:            if (font_bumpmap) {
        -:  667:
     4522:  668:                if (a != glyph_obj->current_angle) {
     3891:  669:                    glyph_obj_update_bumpmap_texture(renderer, glyph_obj,center_x,center_y,a, light_x, light_y);
        -:  670:                }
        -:  671:
     4522:  672:                SDL_Texture *texture = glyph_obj->bumpmap_overlay;
     4522:  673:                log_debug(MENU_CTX,"texture: %p\n", texture);
        -:  674:
     4522:  675:                if (shadow_offset > 0) {
        -:  676:
     4522:  677:                    Uint8 orig_a, orig_r, orig_g, orig_b;
     4522:  678:                    SDL_GetTextureAlphaMod(texture, &orig_a);
     4522:  679:                    SDL_GetTextureColorMod(texture, &orig_r, &orig_g, &orig_b);
     4522:  680:                    SDL_SetTextureColorMod(texture,0,0,0);
        -:  681:
     4522:  682:                    SDL_Rect shadow_dst_rec;
     4522:  683:                    shadow_dst_rec.w = glyph_obj->dst_rect->w;
     4522:  684:                    shadow_dst_rec.h = glyph_obj->dst_rect->h;
        -:  685:
    27132:  686:                    for (int so = shadow_offset; so > 0; so--) {
    22610:  687:                        int sa = (shadow_offset - so + 1)*shadow_alpha / shadow_offset;
    22610:  688:                        SDL_SetTextureAlphaMod(texture,sa);
    22610:  689:                        shadow_dst_rec.x = glyph_obj->dst_rect->x+so*glyph_obj->shadow_dx;
    22610:  690:                        shadow_dst_rec.y = glyph_obj->dst_rect->y+so*glyph_obj->shadow_dy;
    22610:  691:                        SDL_RenderCopyEx(renderer,texture,NULL,&shadow_dst_rec,a, glyph_obj->rot_center,SDL_FLIP_NONE);
        -:  692:                    }
        -:  693:
     4522:  694:                    SDL_SetTextureAlphaMod(texture,orig_a);
     4522:  695:                    SDL_SetTextureColorMod(texture,orig_r, orig_g, orig_b);
        -:  696:
        -:  697:                }
        -:  698:
     4522:  699:                SDL_RenderCopyEx(renderer,texture,NULL,glyph_obj->dst_rect,a, glyph_obj->rot_center,SDL_FLIP_NONE);
        -:  700:
        -:  701:            } else {
        -:  702:
    #####:  703:                if (shadow_offset > 0) {
        -:  704:
    #####:  705:                    SDL_Rect shadow_dst_rec;
    #####:  706:                    shadow_dst_rec.w = glyph_obj->dst_rect->w;
    #####:  707:                    shadow_dst_rec.h = glyph_obj->dst_rect->h;
    #####:  708:                    shadow_dst_rec.x = glyph_obj->dst_rect->x+shadow_offset*glyph_obj->shadow_dx;
    #####:  709:                    shadow_dst_rec.y = glyph_obj->dst_rect->y+shadow_offset*glyph_obj->shadow_dy;
        -:  710:
    #####:  711:                    Uint8 orig_a, orig_r, orig_g, orig_b;
    #####:  712:                    SDL_GetTextureAlphaMod(glyph_obj->texture, &orig_a);
    #####:  713:                    SDL_GetTextureColorMod(glyph_obj->texture, &orig_r, &orig_g, &orig_b);
    #####:  714:                    SDL_SetTextureAlphaMod(glyph_obj->texture,shadow_alpha);
    #####:  715:                    SDL_SetTextureColorMod(glyph_obj->texture,0,0,0);
        -:  716:
    #####:  717:                    SDL_RenderCopyEx(renderer,glyph_obj->texture,NULL,&shadow_dst_rec,a, glyph_obj->rot_center,SDL_FLIP_NONE);
        -:  718:
    #####:  719:                    SDL_SetTextureAlphaMod(glyph_obj->texture,orig_a);
    #####:  720:                    SDL_SetTextureColorMod(glyph_obj->texture,orig_r, orig_g, orig_b);
        -:  721:                }
        -:  722:
    #####:  723:                SDL_RenderCopyEx(renderer,glyph_obj->texture,NULL,glyph_obj->dst_rect,a, glyph_obj->rot_center,SDL_FLIP_NONE);
        -:  724:
        -:  725:            }
        -:  726:        }
        -:  727:
    15780:  728:        glyph_obj->current_angle = a;
    15780:  729:        advance += glyph_obj->advance;
        -:  730:
        -:  731:    }
        -:  732:
     1691:  733:    if (label->glyphs_objs_2nd_line > 0) {
    #####:  734:        circumference = M_2_X_PI * (radius - label->height);
    #####:  735:        advance = - 0.5 * label->width_2nd_line;
    #####:  736:        for (c = 0; c < label->n_glyphs_2nd_line; c++) {
    #####:  737:            glyph_obj *glyph_obj = label->glyphs_objs_2nd_line[c];
    #####:  738:            double a = angle + 360.0 * (advance + 0.5 * glyph_obj->dst_rect->w)/circumference;
        -:  739:
    #####:  740:            if (a >= -VISIBLE_ANGLE || a <= VISIBLE_ANGLE) {
        -:  741:
    #####:  742:                if (font_bumpmap) {
        -:  743:
    #####:  744:                    if (a != glyph_obj->current_angle) {
    #####:  745:                        glyph_obj_update_bumpmap_texture(renderer, glyph_obj,center_x,center_y,a, light_x, light_y);
        -:  746:                    }
        -:  747:
    #####:  748:                    if (shadow_offset > 0) {
        -:  749:
    #####:  750:                        SDL_Rect shadow_dst_rec;
    #####:  751:                        shadow_dst_rec.w = glyph_obj->dst_rect->w;
    #####:  752:                        shadow_dst_rec.h = glyph_obj->dst_rect->h;
    #####:  753:                        shadow_dst_rec.x = glyph_obj->dst_rect->x+shadow_offset*glyph_obj->shadow_dx;
    #####:  754:                        shadow_dst_rec.y = glyph_obj->dst_rect->y+shadow_offset*glyph_obj->shadow_dy;
        -:  755:
    #####:  756:                        Uint8 orig_a, orig_r, orig_g, orig_b;
    #####:  757:                        SDL_GetTextureAlphaMod(glyph_obj->bumpmap_overlay, &orig_a);
    #####:  758:                        SDL_GetTextureColorMod(glyph_obj->bumpmap_overlay, &orig_r, &orig_g, &orig_b);
    #####:  759:                        SDL_SetTextureAlphaMod(glyph_obj->bumpmap_overlay,shadow_alpha);
    #####:  760:                        SDL_SetTextureColorMod(glyph_obj->bumpmap_overlay,0,0,0);
        -:  761:
    #####:  762:                        SDL_RenderCopyEx(renderer,glyph_obj->bumpmap_overlay,NULL,&shadow_dst_rec,a, glyph_obj->rot_center,SDL_FLIP_NONE);
        -:  763:
    #####:  764:                        SDL_SetTextureAlphaMod(glyph_obj->bumpmap_overlay,orig_a);
    #####:  765:                        SDL_SetTextureColorMod(glyph_obj->bumpmap_overlay,orig_r, orig_g, orig_b);
        -:  766:
        -:  767:                    }
    #####:  768:                    SDL_RenderCopyEx(renderer,glyph_obj->bumpmap_overlay,NULL,glyph_obj->dst_rect,a, glyph_obj->rot_center,SDL_FLIP_NONE);
        -:  769:                } else {
    #####:  770:                    if (shadow_offset > 0) {
        -:  771:
    #####:  772:                        SDL_Rect shadow_dst_rec;
    #####:  773:                        shadow_dst_rec.w = glyph_obj->dst_rect->w;
    #####:  774:                        shadow_dst_rec.h = glyph_obj->dst_rect->h;
    #####:  775:                        shadow_dst_rec.x = glyph_obj->dst_rect->x+shadow_offset*glyph_obj->shadow_dx;
    #####:  776:                        shadow_dst_rec.y = glyph_obj->dst_rect->y+shadow_offset*glyph_obj->shadow_dy;
        -:  777:
    #####:  778:                        Uint8 orig_a, orig_r, orig_g, orig_b;
    #####:  779:                        SDL_GetTextureAlphaMod(glyph_obj->texture, &orig_a);
    #####:  780:                        SDL_GetTextureColorMod(glyph_obj->texture, &orig_r, &orig_g, &orig_b);
    #####:  781:                        SDL_SetTextureAlphaMod(glyph_obj->texture,shadow_alpha);
    #####:  782:                        SDL_SetTextureColorMod(glyph_obj->texture,0,0,0);
        -:  783:
    #####:  784:                        SDL_RenderCopyEx(renderer,glyph_obj->texture,NULL,&shadow_dst_rec,a, glyph_obj->rot_center,SDL_FLIP_NONE);
        -:  785:
    #####:  786:                        SDL_SetTextureAlphaMod(glyph_obj->texture,orig_a);
    #####:  787:                        SDL_SetTextureColorMod(glyph_obj->texture,orig_r, orig_g, orig_b);
        -:  788:                    }
    #####:  789:                    SDL_RenderCopyEx(renderer,glyph_obj->texture,NULL,glyph_obj->dst_rect,a, glyph_obj->rot_center,SDL_FLIP_NONE);
        -:  790:                }
        -:  791:            }
    #####:  792:            glyph_obj->current_angle = a;
    #####:  793:            advance += glyph_obj->advance;
        -:  794:        }
        -:  795:    }
        -:  796:
     1691:  797:    if (target != NULL) {
    #####:  798:        SDL_SetRenderTarget(renderer,NULL);
    #####:  799:        SDL_RenderCopy(renderer,target,NULL,NULL);
        -:  800:    }
        -:  801:
        -:  802:}
        -:  803:
    #####:  804:void menu_item_update_cnt_rad(menu_item *item, SDL_Point center, int radius) {
        -:  805:
    #####:  806:    int lines = 1;
    #####:  807:    if (item->num_label_chars2 > 0) {
    #####:  808:        lines = 2;
        -:  809:    }
        -:  810:
    #####:  811:    int line;
    #####:  812:    for (line = 0; line < lines; line++) {
        -:  813:
    #####:  814:        text_obj_update_cnt_rad(item->label_default, center, radius, item->line, item->menu->n_o_lines, item->menu->ctrl->light_x, item->menu->ctrl->light_y);
    #####:  815:        text_obj_update_cnt_rad(item->label_active, center, radius, item->line, item->menu->n_o_lines, item->menu->ctrl->light_x, item->menu->ctrl->light_y);
    #####:  816:        text_obj_update_cnt_rad(item->label_current, center, radius, item->line, item->menu->n_o_lines, item->menu->ctrl->light_x, item->menu->ctrl->light_y);
        -:  817:
        -:  818:    }
        -:  819:
    #####:  820:}
        -:  821:
     1799:  822:int menu_item_draw(menu_item *item, menu_item_state st, double angle) {
        -:  823:
     1799:  824:    log_config(MENU_CTX, "menu_item_draw: label = %s, line = %d, state = %d, angle = %f\n", item->label, item->line, st, angle);
        -:  825:
     1799:  826:    int lines = 1;
     1799:  827:    if (item->num_label_chars2 > 0) {
    #####:  828:        lines = 2;
        -:  829:    }
        -:  830:
     1799:  831:    int line;
     3598:  832:    for (line = 0; line < lines; line++) {
        -:  833:
     1799:  834:        text_obj *label = item->label_default;
     1799:  835:        if (st == ACTIVE) {
       16:  836:            label = item->label_active;
     1783:  837:        } else if (st == SELECTED) {
      299:  838:            label = item->label_current;
        -:  839:        }
        -:  840:
     1799:  841:        text_obj_draw(item->menu->ctrl->renderer,NULL,label,item->menu->radius_labels,item->menu->ctrl->center.x,item->menu->ctrl->center.y,angle,item->line,item->menu->ctrl->light_x,item->menu->ctrl->light_y, item->menu->ctrl->font_bumpmap, item->menu->ctrl->shadow_offset, item->menu->ctrl->shadow_alpha);
        -:  842:
        -:  843:    }
        -:  844:
     1799:  845:    return 0;
        -:  846:
        -:  847:}
        -:  848:
    #####:  849:const void *menu_item_get_object(menu_item *item) {
    #####:  850:    return item->object;
        -:  851:}
        -:  852:
    #####:  853:void menu_item_set_object(menu_item *item, void *object) {
    #####:  854:    item->object = object;
    #####:  855:}
        -:  856:
    #####:  857:Uint16 *menu_item_get_label(menu_item *i) {
    #####:  858:    return i->unicode_label;
        -:  859:}
        -:  860:
    #####:  861:menu *menu_item_get_sub_menu(menu_item *item) {
    #####:  862:    return item->sub_menu;
        -:  863:}
        -:  864:
    #####:  865:menu *menu_item_get_menu(menu_item *item) {
    #####:  866:    return item->menu;
        -:  867:}
        -:  868:
    #####:  869:int menu_item_is_sub_menu(menu_item *item) {
    #####:  870:    return item->sub_menu != 0;
        -:  871:}
        -:  872:
    #####:  873:void menu_item_set_sub_menu(menu_item *item, menu *sub_menu) {
    #####:  874:    item->sub_menu = sub_menu;
    #####:  875:}
        -:  876:
    #####:  877:int menu_item_get_object_type(menu_item *item) {
    #####:  878:    return item->object_type;
        -:  879:}
        -:  880:
    #####:  881:void menu_item_set_object_type(menu_item *item, int object_type) {
    #####:  882:    item->object_type = object_type;
    #####:  883:}
        -:  884:
    #####:  885:int menu_item_get_id(menu_item *item) {
    #####:  886:    return item->id;
        -:  887:}
        -:  888:
       54:  889:void menu_item_rebuild_glyphs(menu_item *item) {
        -:  890:
       54:  891:    menu *m = item->menu;
        -:  892:
       54:  893:    if (item->label_default) {
       20:  894:        text_obj_free(item->label_default);
       20:  895:        item->label_default = NULL;
        -:  896:    }
        -:  897:
       54:  898:    if (item->label_current) {
       20:  899:        text_obj_free(item->label_current);
       20:  900:        item->label_current = NULL;
        -:  901:    }
        -:  902:
       54:  903:    if (item->label_active) {
       20:  904:        text_obj_free(item->label_active);
       20:  905:        item->label_active = NULL;
        -:  906:    }
        -:  907:
       54:  908:    TTF_Font *font = item->font;
       54:  909:    if (!font) {
    #####:  910:        font = m->ctrl->font;
        -:  911:    }
        -:  912:
       54:  913:    TTF_Font *font2 = item->font2;
       54:  914:    if (!font2) {
    #####:  915:        font2 = m->ctrl->font2;
        -:  916:    }
        -:  917:
       54:  918:    SDL_Renderer *renderer = m->ctrl->renderer;
       54:  919:    item->label_default = text_obj_new(renderer,item->label,font,font2,m->default_color != NULL ? *m->default_color : *m->ctrl->default_color,m->ctrl->center,m->radius_labels,item->line, m->n_o_lines, item->menu->ctrl->light_x, item->menu->ctrl->light_y);
       54:  920:    item->label_current = text_obj_new(renderer,item->label,font,font2,m->selected_color != NULL ? *m->selected_color : *m->ctrl->selected_color,m->ctrl->center,m->radius_labels,item->line, m->n_o_lines, item->menu->ctrl->light_x, item->menu->ctrl->light_y);
       54:  921:    item->label_active = text_obj_new(renderer,item->label,font,font2,m->default_color != NULL ? *m->default_color : *m->ctrl->activated_color,m->ctrl->center,m->radius_labels,item->line, m->n_o_lines, item->menu->ctrl->light_x, item->menu->ctrl->light_y);
        -:  922:
       54:  923:}
        -:  924:
       84:  925:int menu_item_set_label(menu_item *item, const char *label) {
        -:  926:
       84:  927:    if (!item->label || strcmp(item->label, label)) {
       54:  928:        const char *llabel = (label ? label : "");
       54:  929:        if (item->label) {
       20:  930:            free(item->label);
       20:  931:            item->label = NULL;
        -:  932:        }
        -:  933:
       54:  934:        item->label = my_copystr(llabel);
        -:  935:
       54:  936:        menu_item_rebuild_glyphs(item);
        -:  937:
       54:  938:        item->menu->dirty = 1;
        -:  939:
        -:  940:    }
        -:  941:
       84:  942:    return 1;
        -:  943:}
        -:  944:
       34:  945:menu_item *menu_item_new(menu *m, const char *label, void *object, int object_type,
        -:  946:                         const char *font, int font_size, item_action *action, char *font_2nd_line, int font_size_2nd_line) {
        -:  947:
       34:  948:    menu_item *item = malloc(sizeof(menu_item));
       34:  949:    item->unicode_label = NULL;
       34:  950:    item->unicode_label2 = NULL;
       34:  951:    item->utf8_label = NULL;
       34:  952:    item->label = NULL;
       34:  953:    item->object = object;
       34:  954:    item->object_type = object_type;
       34:  955:    item->is_sub_menu = 0;
       34:  956:    item->menu = m;
       34:  957:    item->action = action;
       34:  958:    m->max_id++;
       34:  959:    item->id = m->max_id;
        -:  960:
       34:  961:    item->line = (item->id % m->n_o_lines) + 1 - m->n_o_lines;
        -:  962:
       34:  963:    if (m->item) {
       27:  964:        m->item = realloc(m->item, (Uint32) (m->max_id + 1) * sizeof(menu_item *));
        -:  965:    } else {
        7:  966:        m->item = malloc((Uint32) (m->max_id + 1) * sizeof(menu_item *));
        -:  967:    }
       34:  968:    m->item[m->max_id] = item;
       34:  969:    item->font = NULL;
       34:  970:    item->font2 = NULL;
       34:  971:    item->glyph_objs = NULL;
       34:  972:    item->glyph_objs2 = NULL;
       34:  973:    item->num_label_chars = 0;
       34:  974:    item->num_label_chars2 = 0;
       34:  975:    item->label_active = NULL;
       34:  976:    item->label_current = NULL;
       34:  977:    item->label_default = NULL;
        -:  978:
        -:  979:    /* Initialize fonts */
        -:  980:
       34:  981:    if (font && font_size > 0) {
        6:  982:        TTF_Font *dflt_font = TTF_OpenFont(font, font_size);
        6:  983:        if (!dflt_font) {
    #####:  984:            log_error(MENU_CTX, "Failed to load font: %s. Trying fixed font\n", SDL_GetError());
    #####:  985:            dflt_font = TTF_OpenFont("fixed", font_size);
    #####:  986:            if (!dflt_font) {
    #####:  987:                log_error(MENU_CTX, "Failed to load font: %s\n", SDL_GetError());
        -:  988:            }
        -:  989:        }
        6:  990:        if (dflt_font) {
        6:  991:            item->font = dflt_font;
        -:  992:        }
        -:  993:    } else {
       28:  994:        item->font = m->ctrl->font;
        -:  995:    }
        -:  996:
       34:  997:    if (font_2nd_line) {
        2:  998:        if (font_size_2nd_line <= 0) {
    #####:  999:            font_size_2nd_line = font_size;
        -: 1000:        }
        2: 1001:        TTF_Font *dflt_font = TTF_OpenFont(font_2nd_line, font_size_2nd_line);
        2: 1002:        if (!dflt_font) {
    #####: 1003:            log_error(MENU_CTX, "Failed to load font: %s. Trying fixed font\n", SDL_GetError());
    #####: 1004:            dflt_font = TTF_OpenFont("fixed", font_size_2nd_line);
    #####: 1005:            if (!dflt_font) {
    #####: 1006:                log_error(MENU_CTX, "Failed to load font: %s\n", SDL_GetError());
        -: 1007:            }
        -: 1008:        }
        2: 1009:        if (dflt_font) {
        2: 1010:            item->font2 = dflt_font;
        -: 1011:        }
        -: 1012:    } else {
       32: 1013:        item->font2 = m->ctrl->font2;
        -: 1014:    }
        -: 1015:
       34: 1016:    menu_item_set_label(item, label);
        -: 1017:
       34: 1018:    return item;
        -: 1019:
        -: 1020:}
        -: 1021:
    #####: 1022:int menu_item_dispose(menu_item *item) {
    #####: 1023:    log_config(MENU_CTX, "Start dispose_menu_item\n");
        -: 1024:
    #####: 1025:    menu *m = (menu *) item->menu;
        -: 1026:
    #####: 1027:    if (!m) {
    #####: 1028:        log_error(MENU_CTX, "Item %s has no menu!\n", item->unicode_label);
    #####: 1029:        return 1;
        -: 1030:    }
        -: 1031:
    #####: 1032:    menu_ctrl *ctrl = (menu_ctrl *) m->ctrl;
        -: 1033:
    #####: 1034:    if (ctrl->action) {
        -: 1035:        // To dispose the object
    #####: 1036:        ctrl->action(DISPOSE,m,item);
        -: 1037:    }
        -: 1038:
    #####: 1039:    if (item->is_sub_menu && item->sub_menu) {
    #####: 1040:        menu_clear((menu *)item->sub_menu);
    #####: 1041:        log_config(MENU_CTX, "free(item->sub_menu -> %p)\n", item->sub_menu);
    #####: 1042:        free(item->sub_menu);
    #####: 1043:        item->sub_menu = NULL;
        -: 1044:    }
        -: 1045:
    #####: 1046:    if (item->unicode_label) {
    #####: 1047:        log_config(MENU_CTX, "free(item->unicode_label -> %p)\n", item->unicode_label);
    #####: 1048:        free(item->unicode_label);
        -: 1049:    }
    #####: 1050:    log_config(MENU_CTX, "free(item -> %p)\n", item);
    #####: 1051:    free(item);
    #####: 1052:    log_config(MENU_CTX, "End dispose_menu_item\n");
    #####: 1053:    return 0;
        -: 1054:}
        -: 1055:
    #####: 1056:menu_item *menu_item_next(menu *m, menu_item *item) {
    #####: 1057:    if (item) {
    #####: 1058:        if (item->id < m->max_id) {
    #####: 1059:            return m->item[item->id+1];
        -: 1060:        }
        -: 1061:    }
        -: 1062:    return 0;
        -: 1063:}
        -: 1064:
       50: 1065:menu_item *menu_item_update_label(menu_item *item, const char *label) {
       50: 1066:    log_config(MENU_CTX, "menu_item_update_label(item -> %p, label -> %s)\n", item, label);
       50: 1067:    menu *m = (menu *) item->menu;
       50: 1068:    menu_item_set_label(item, label);
       50: 1069:    menu_ctrl_draw(m->ctrl);
       50: 1070:    return item;
        -: 1071:}
        -: 1072:
    #####: 1073:void menu_item_activate(menu_item *item) {
    #####: 1074:    menu *m = (menu *) item->menu;
    #####: 1075:    menu_ctrl *ctrl = (menu_ctrl *) m->ctrl;
    #####: 1076:    menu_item_warp_to(item);
    #####: 1077:    m->active_id = item->id;
    #####: 1078:    menu_ctrl_draw(ctrl);
    #####: 1079:}
        -: 1080:
       30: 1081:void menu_item_debug(menu_item *item) {
       30: 1082:    log_debug(MENU_CTX, "Ptr:   %p\n",item);
       30: 1083:    log_debug(MENU_CTX, "Label: %s\n",item->utf8_label);
       30: 1084:    log_debug(MENU_CTX, "Id:    %d\n",item->id);
       30: 1085:    log_debug(MENU_CTX, "Length: %d\n",item->num_label_chars);
       30: 1086:}
        -: 1087:
       30: 1088:void menu_item_show(menu_item *item) {
       30: 1089:    menu_item_debug(item);
       30: 1090:    menu *m = (menu *) item->menu;
       30: 1091:    menu_ctrl *ctrl = (menu_ctrl *) m->ctrl;
       30: 1092:    if (m != ctrl->current) {
        1: 1093:        ctrl->warping = 1;
        1: 1094:        ctrl->current = m;
        1: 1095:        if (!m->transient) {
    #####: 1096:            ctrl->active = m;
        -: 1097:        }
        1: 1098:        m->radius_labels = ctrl->radius_labels;
        1: 1099:        m->radius_scales_start = ctrl->radius_scales_start;
        1: 1100:        m->radius_scales_end = ctrl->radius_scales_end;
        1: 1101:        m->current_id = item->id;
        1: 1102:        m->active_id = item->id;
        1: 1103:        m->segment = 0;
        1: 1104:        menu_ctrl_draw(ctrl);
        1: 1105:        ctrl->warping = 0;
        -: 1106:    }
       30: 1107:}
        -: 1108:
        4: 1109:void menu_item_warp_to(menu_item *item) {
        -: 1110:
        4: 1111:    log_config(MENU_CTX, "menu_item_warp_to: menu_item->menu->ctrl->object = %p->%p->%p->%p\n", item, item->menu, item->menu->ctrl, item->menu->ctrl->object);
        4: 1112:    menu *m = (menu *) item->menu;
        4: 1113:    menu_ctrl *ctrl = (menu_ctrl *) m->ctrl;
        4: 1114:    if (m != ctrl->current) {
        1: 1115:        menu_fade_out(ctrl->current, m);
        1: 1116:        ctrl->current = m;
        1: 1117:        if (!m->transient) {
    #####: 1118:            ctrl->active = m;
        -: 1119:        }
        -: 1120:    }
        -: 1121:
        4: 1122:    ctrl->warping = 1;
        -: 1123:
       4*: 1124:    int dist_right  = (item->id < m->current_id) ? m->current_id - item->id : m->current_id + m->max_id - item->id;
       4*: 1125:    int dist_left   = (item->id < m->current_id) ? m->max_id - m->current_id + item->id : item->id - m->current_id;
        -: 1126:
        4: 1127:    if (dist_right < dist_left) {
    #####: 1128:        while (item->id != m->current_id && ctrl->warping) {
    #####: 1129:            menu_turn_right(m);
    #####: 1130:            menu_ctrl_process_events(ctrl);
        -: 1131:        }
        -: 1132:    } else {
       20: 1133:        while (item->id != m->current_id && ctrl->warping) {
       16: 1134:            menu_turn_left(m);
       16: 1135:            menu_ctrl_process_events(ctrl);
        -: 1136:        }
        -: 1137:    }
        -: 1138:
        -: 1139:    // Lock in
       4*: 1140:    while (m->segment < 0 && ctrl->warping) {
    #####: 1141:        menu_turn_right(m);
    #####: 1142:        menu_ctrl_process_events(ctrl);
        -: 1143:    }
        -: 1144:
       16: 1145:    while (m->segment > 0 && ctrl->warping) {
       12: 1146:        menu_turn_left(m);
       12: 1147:        menu_ctrl_process_events(ctrl);
        -: 1148:    }
        -: 1149:
        4: 1150:    ctrl->warping = 0;
        -: 1151:    //menu_ctrl_draw(ctrl);
        4: 1152:    log_config(MENU_CTX, "menu_item_warp_to: ctrl->object = %p->%p\n", ctrl, ctrl->object);
        -: 1153:
        4: 1154:}
        -: 1155:
      245: 1156:int do_clear(menu_ctrl *ctrl, double angle, SDL_Color *background_color, SDL_Texture *bg_image) {
      245: 1157:    if (background_color) {
      245: 1158:        SDL_SetRenderDrawColor(ctrl->renderer,background_color->r,
      245: 1159:                               background_color->g,
      245: 1160:                               background_color->b, 255);
      245: 1161:        if (SDL_RenderClear(ctrl->renderer) < 0) {
    #####: 1162:            log_error(MENU_CTX, "Failed to render background: %s\n", SDL_GetError());
    #####: 1163:            return 0;
        -: 1164:        }
        -: 1165:    }
        -: 1166:
      245: 1167:    if (!bg_image) {
      145: 1168:        bg_image = ctrl->bg_image;
        -: 1169:    }
        -: 1170:
      245: 1171:    if (bg_image) {
      245: 1172:        int w, h;
      245: 1173:        SDL_QueryTexture(bg_image,NULL,NULL,&w,&h);
      245: 1174:        double xo = ctrl->center.x - 0.5 * w;
      245: 1175:        double yo = ctrl->center.y - 0.5 * h;
      245: 1176:        const SDL_FRect dst_rect = {xo, yo, w, h};
      245: 1177:        double xc = 0.5 * dst_rect.w;
      245: 1178:        double yc = 0.5 * dst_rect.h;
      245: 1179:        const SDL_FPoint center = {xc,yc};
        -: 1180:
      245: 1181:        if (SDL_RenderCopyExF(ctrl->renderer, bg_image, NULL, &dst_rect, angle, &center, SDL_FLIP_NONE) == -1) {
        1: 1182:            log_error(MENU_CTX, "Failed to render background: %s\n", SDL_GetError());
        1: 1183:            return 0;
        -: 1184:        }
        -: 1185:    }
        -: 1186:
        -: 1187:    return 1;
        -: 1188:}
        -: 1189:
        8: 1190:void menu_fade_out(menu *menu_frm, menu *menu_to) {
        8: 1191:    menu_ctrl *ctrl = (menu_ctrl *) menu_frm->ctrl;
        8: 1192:    ctrl->warping = 1;
        8: 1193:    double R_frm = menu_frm ? menu_frm->radius_scales_end : 0.0;
        8: 1194:    double r_frm = menu_frm ? menu_frm->radius_labels : 0.0;
        8: 1195:    double d_frm = R_frm - r_frm;
        -: 1196:
        8: 1197:    double R_to = r_frm;
        8: 1198:    double r_to = 0;
        -: 1199:
        8: 1200:    int s = 5;
        8: 1201:    double ds = (double) s;
        8: 1202:    double inv_ds = 1 / ds;
        -: 1203:
        8: 1204:    int i = 0;
       56: 1205:    for (i = 0; i <= s; i++) {
        -: 1206:
       48: 1207:        double x = (double) i;
       48: 1208:        double x_1 = ds - x;
        -: 1209:
       48: 1210:        if (menu_frm) {
      48*: 1211:            menu_frm->radius_labels = to_int(inv_ds * (x * R_frm + x_1 * r_frm));
      48*: 1212:            menu_frm->radius_scales_end = to_int(inv_ds * (x * (R_frm + d_frm) + x_1 * R_frm));
       48: 1213:            menu_frm->dirty = 1;
       48: 1214:            menu_draw(menu_frm, 1, 0);
        -: 1215:        }
      48*: 1216:        menu_to->radius_labels = to_int(inv_ds * (x * r_frm + x_1 * r_to));
      48*: 1217:        menu_to->radius_scales_end = to_int(inv_ds * (x * R_frm + x_1 * R_to));
       48: 1218:        menu_to->dirty = 1;
       48: 1219:        menu_draw(menu_to, 0, 1);
        -: 1220:    }
        8: 1221:    menu_to->dirty = 1;
        8: 1222:    menu_draw(menu_to, 1, 1);
        8: 1223:    if (!menu_to->transient) {
        7: 1224:        ctrl->active = menu_to;
        -: 1225:    }
        8: 1226:}
        -: 1227:
        6: 1228:void menu_fade_in(menu *menu_frm, menu *menu_to) {
        6: 1229:    menu_ctrl *ctrl = (menu_ctrl *) menu_frm->ctrl;
        6: 1230:    ctrl->warping = 1;
        6: 1231:    double R_frm = menu_frm->radius_scales_end;
        6: 1232:    double r_frm = menu_frm->radius_labels;
        6: 1233:    double d_frm = R_frm - r_frm;
        -: 1234:
        6: 1235:    double r_to = R_frm;
        6: 1236:    double R_to = R_frm + d_frm;
        -: 1237:
        6: 1238:    int s = 5;
        6: 1239:    double ds = (double) s;
        6: 1240:    double inv_ds = 1 / ds;
        -: 1241:
        6: 1242:    int i = 0;
       42: 1243:    for (i = 0; i <= s; i++) {
        -: 1244:
       36: 1245:        double x = (double) i;
       36: 1246:        double x_1 = ds - x;
        -: 1247:
      36*: 1248:        menu_frm->radius_labels = to_int(inv_ds * x_1 * r_frm);
      36*: 1249:        menu_frm->radius_scales_end = to_int(inv_ds * (x * r_frm + x_1 * R_frm));
       36: 1250:        menu_to->radius_labels = to_int(inv_ds * (x * r_frm + x_1 * r_to));
      36*: 1251:        menu_to->radius_scales_end = to_int(inv_ds * (x * R_frm + x_1 * R_to));
       36: 1252:        menu_frm->dirty = 1;
       36: 1253:        menu_draw(menu_frm, 1, 0);
       36: 1254:        menu_to->dirty = 1;
       36: 1255:        menu_draw(menu_to, 0, 1);
        -: 1256:    }
        6: 1257:    menu_to->dirty = 1;
        6: 1258:    menu_draw(menu_to, 1, 1);
        6: 1259:    if (!menu_to->transient) {
        6: 1260:        ctrl->active = menu_to;
        -: 1261:    }
        6: 1262:}
        -: 1263:
        6: 1264:int menu_open_sub_menu(menu_ctrl *ctrl, menu_item *item) {
        -: 1265:
        6: 1266:    menu *sub_menu = (menu *) item->sub_menu;
        6: 1267:    sub_menu->segment = 0;
        6: 1268:    menu_fade_out(ctrl->current, sub_menu);
        6: 1269:    ctrl->current = sub_menu;
        6: 1270:    if (!sub_menu->transient) {
        6: 1271:        ctrl->active = ctrl->current;
        -: 1272:    }
        6: 1273:    return 1;
        -: 1274:}
        -: 1275:
        1: 1276:int menu_open(menu *m) {
        1: 1277:    menu_ctrl *ctrl = m->ctrl;
        1: 1278:    if (ctrl->current != m) {
        1: 1279:        m->segment = 0;
        1: 1280:        menu_fade_out(ctrl->current, m);
        1: 1281:        ctrl->current = m;
        1: 1282:        if (!m->transient) {
        1: 1283:            ctrl->active = ctrl->current;
        -: 1284:        }
        -: 1285:    }
        1: 1286:    return 1;
        -: 1287:}
        -: 1288:
    #####: 1289:int menu_get_max_id(menu *m) {
    #####: 1290:    return m->max_id;
        -: 1291:}
        -: 1292:
    #####: 1293:menu_item *menu_get_item(menu *m, int id) {
    #####: 1294:    return m->item[id];
        -: 1295:}
        -: 1296:
      329: 1297:int menu_draw_scales(menu *m, double xc, double yc, double angle) {
        -: 1298:
      329: 1299:    menu_ctrl *ctrl = m->ctrl;
        -: 1300:
      329: 1301:    int no_of_mini_scales = 2;
        -: 1302:
      329: 1303:    double a = angle;
      329: 1304:    double angle_step = 360.0 / ((no_of_mini_scales+1) * ctrl->no_of_scales);
      329: 1305:    double fr = m->radius_scales_start;
      329: 1306:    double fR = m->radius_scales_end;
        -: 1307:
        -: 1308:    /* Draw the scales */
        -: 1309:
    12173: 1310:    for (int s = 0; s < ctrl->no_of_scales; s++) {
        -: 1311:
    11844: 1312:        menu_ctrl_draw_scale(ctrl, xc, yc, fr-20, fR, a, 255, 0);
        -: 1313:
    11844: 1314:        a += angle_step;
        -: 1315:
    11844: 1316:        int sd;
    35532: 1317:        for (sd = 0; sd < no_of_mini_scales; sd++) {
        -: 1318:
    23688: 1319:            menu_ctrl_draw_scale(ctrl,xc,yc,fr,fR,a, 255, 0);
        -: 1320:
    23688: 1321:            a += angle_step;
        -: 1322:
        -: 1323:        }
        -: 1324:
        -: 1325:    }
        -: 1326:
      329: 1327:    return 0;
        -: 1328:
        -: 1329:}
        -: 1330:
      245: 1331:int menu_wipe(menu *m, double angle) {
      245: 1332:    return do_clear(m->ctrl, angle, m->ctrl->background_color, m->bg_image);
        -: 1333:}
        -: 1334:
      466: 1335:int menu_draw(menu *m, int clear, int render) {
        -: 1336:
        -: 1337:
      466: 1338:    if (!m) {
        -: 1339:        return 0;
        -: 1340:    }
        -: 1341:
      466: 1342:    if (!m->dirty) {
        -: 1343:        return 0;
        -: 1344:    }
        -: 1345:
      329: 1346:    m->dirty = 0;
        -: 1347:
      329: 1348:    log_debug(MENU_CTX, "START: menu_draw\n");
      329: 1349:    render_start_ticks = SDL_GetTicks();
        -: 1350:
      329: 1351:    menu_ctrl *ctrl = (menu_ctrl *) m->ctrl;
        -: 1352:
      329: 1353:    double xc = ctrl->center.x;
      329: 1354:    double yc = ctrl->center.y;
        -: 1355:
        -: 1356:    // Eventually change background color according to time of day
      329: 1357:    if (ctrl->bg_color_of_time) {
    #####: 1358:        time_t timer;
    #####: 1359:        time(&timer);
    #####: 1360:        struct tm *tm_info = localtime(&timer);
    #####: 1361:        int t = tm_info->tm_hour * 60 + tm_info->tm_min;
    #####: 1362:        if (t != current_hour) {
        -: 1363:
    #####: 1364:            double m = (double) t;
        -: 1365:
    #####: 1366:            if (ctrl->bg_color_palette) {
    #####: 1367:                int col_idx = (int) (m * (double) ctrl->bg_cp_colors / 1440.0);
    #####: 1368:                char *bg_color = ctrl->bg_color_palette[col_idx];
    #####: 1369:                SDL_Color *bg = html_to_color(bg_color);
    #####: 1370:                menu_ctrl_set_bg_color_rgb(ctrl, bg->r,bg->g,bg->b);
    #####: 1371:                free(bg);
        -: 1372:            } else {
    #####: 1373:                double hue = 360.0 * (m-720.0+240.0)/1440.0;
        -: 1374:
    #####: 1375:                if (hue < 0.0) {
    #####: 1376:                    hue = hue + 1.0;
    #####: 1377:                } else if (hue > 1.0) {
    #####: 1378:                    hue = hue - 1.0;
        -: 1379:                }
        -: 1380:
    #####: 1381:                menu_ctrl_set_bg_color_hsv(ctrl, hue, 50.0, 100.0);
        -: 1382:
    #####: 1383:                current_hour = t;
        -: 1384:            }
        -: 1385:
        -: 1386:
        -: 1387:        }
        -: 1388:    }
        -: 1389:
      329: 1390:    double angle = ctrl->angle_offset + m->segment * 360.0 / (m->n_o_items_on_scale*(2.0*m->segments_per_item+1));
      329: 1391:    log_debug(MENU_CTX,"segment: %f, angle: %f\n", m->segment, angle);
      329: 1392:    if (clear) {
      245: 1393:        double bg_angle = ctrl->angle_offset + ctrl->bg_segment * 360.0 / (m->n_o_items_on_scale*(2.0*m->segments_per_item+1));
      245: 1394:        menu_wipe(m,bg_angle);
        -: 1395:    }
        -: 1396:
      329: 1397:    if (ctrl->draw_scales) {
      329: 1398:        menu_draw_scales(m, xc, yc, angle);
        -: 1399:    }
        -: 1400:
      329: 1401:    if (m->max_id >= 0) {
        -: 1402:
      315: 1403:        int i;
      315: 1404:        int count_drawn_items = (ctrl->warping && !m->draw_only_active) ? 0.5 * m->n_o_items_on_scale : 0;
        -: 1405:
      315: 1406:        double item_angle_steps = 360 / m->n_o_items_on_scale;
        -: 1407:
     2114: 1408:        for (i = -count_drawn_items; i <= count_drawn_items; i++) {
        -: 1409:
     1799: 1410:            int current_item = m->current_id + i;
     1799: 1411:            if (current_item < 0) {
      434: 1412:                current_item = current_item + m->max_id + 1;
        -: 1413:            }
        -: 1414:
     1799: 1415:            current_item %= (m->max_id + 1);
        -: 1416:
     1799: 1417:            menu_item_state st = DEFAULT;
     1799: 1418:            if (current_item == m->active_id) {
        -: 1419:                st = ACTIVE;
     1783: 1420:            } else if (i == 0) {
      299: 1421:                st = SELECTED;
        -: 1422:            }
        -: 1423:
        -: 1424:
     1799: 1425:            double item_angle = angle + i * item_angle_steps;
        -: 1426:
     1799: 1427:            if (item_angle > 360.0) {
    #####: 1428:                item_angle -= 360.0;
        -: 1429:            }
        -: 1430:
     1799: 1431:            if (item_angle < - 360.0) {
    #####: 1432:                item_angle += 360.0;
        -: 1433:            }
        -: 1434:
     1799: 1435:            menu_item_draw(m->item[current_item],st,item_angle);
        -: 1436:
        -: 1437:        }
        -: 1438:    }
        -: 1439:
     329*: 1440:    Sint16 xc_Sint16 = to_Sint16(xc);
      329: 1441:    SDL_SetRenderDrawColor(ctrl->renderer, ctrl->indicator_color->r,
      329: 1442:                           ctrl->indicator_color->g, ctrl->indicator_color->b, ctrl->indicator_alpha);
      329: 1443:    SDL_RenderDrawLine(ctrl->renderer, xc_Sint16, 0, xc_Sint16, (Sint16) ctrl->w);
      329: 1444:    SDL_RenderDrawLine(ctrl->renderer, xc_Sint16 - 1, 0, xc_Sint16 - 1, (Sint16) ctrl->w);
      329: 1445:    SDL_RenderDrawLine(ctrl->renderer, xc_Sint16 + 1, 0, xc_Sint16 + 1, (Sint16) ctrl->w);
      329: 1446:    SDL_SetRenderDrawColor(ctrl->renderer, ctrl->indicator_color_light->r,
      329: 1447:                           ctrl->indicator_color_light->g, ctrl->indicator_color_light->b, ctrl->indicator_alpha * 180 / 255);
      329: 1448:    SDL_RenderDrawLine(ctrl->renderer, xc_Sint16 - 2, 0, xc_Sint16 - 2, (Sint16) ctrl->h);
      329: 1449:    SDL_SetRenderDrawColor(ctrl->renderer, ctrl->indicator_color_dark->r,
      329: 1450:                           ctrl->indicator_color_dark->g, ctrl->indicator_color_dark->b, ctrl->indicator_alpha * 180 / 255);
      329: 1451:    SDL_RenderDrawLine(ctrl->renderer, xc_Sint16 + 2, 0, xc_Sint16 + 2, (Sint16) ctrl->h);
        -: 1452:
      329: 1453:    menu_ctrl_apply_light(ctrl);
        -: 1454:
        -: 1455:
      329: 1456:    if (render) {
      245: 1457:        SDL_RenderPresent(ctrl->renderer);
        -: 1458:    }
        -: 1459:
      329: 1460:    Uint32 render_passed_ticks = SDL_GetTicks()-render_start_ticks;
      329: 1461:    if (render_passed_ticks > 0) {
      296: 1462:        log_debug(MENU_CTX, "Render FPS: %f\n", 1000.0/(double)render_passed_ticks);
        -: 1463:    }
        -: 1464:
        -: 1465:    return 0;
        -: 1466:
        -: 1467:}
        -: 1468:
        1: 1469:int menu_clear(menu *m) {
        1: 1470:    log_config(MENU_CTX, "Start clear_menu, max_id=%d\n", m->max_id);
        1: 1471:    int id = m->max_id;
        1: 1472:    while (id >= 0) {
    #####: 1473:        log_config(MENU_CTX, "%d\n",id);
    #####: 1474:        menu_item_dispose(m->item[id]);
    #####: 1475:        m->item[id] = 0;
    #####: 1476:        id--;
        -: 1477:    }
        -: 1478:
        1: 1479:    m->max_id = -1;
        1: 1480:    m->active_id = -1;
        1: 1481:    m->current_id = 0;
        -: 1482:
        1: 1483:    m->segment = 0;
        -: 1484:
        1: 1485:    log_config(MENU_CTX, "End clear_menu\n");
        1: 1486:    return 0;
        -: 1487:}
        -: 1488:
        9: 1489:menu *menu_new(menu_ctrl *ctrl, int lines) {
        -: 1490:
        9: 1491:    menu *m = malloc(sizeof(menu));
        -: 1492:
        9: 1493:    m->max_id = -1;
        9: 1494:    m->active_id = -1;
        9: 1495:    m->current_id = 0;
        9: 1496:    m->object = 0;
        -: 1497:
        9: 1498:    m->radius_labels = ctrl->radius_labels;
        9: 1499:    m->radius_scales_start = ctrl->radius_scales_start;
        9: 1500:    m->radius_scales_end = ctrl->radius_scales_end;
        -: 1501:
        9: 1502:    m->parent = m;
        9: 1503:    m->item = NULL;
        9: 1504:    m->segment = 0;
        9: 1505:    m->label = 0;
        9: 1506:    m->object = 0;
        9: 1507:    m->bg_image = NULL;
        9: 1508:    m->default_color = NULL;
        9: 1509:    m->selected_color = NULL;
        -: 1510:
        9: 1511:    m->ctrl = ctrl;
        -: 1512:
        9: 1513:    m->transient = 0;
        9: 1514:    m->draw_only_active = 0;
        9: 1515:    m->n_o_lines = lines;
        9: 1516:    m->n_o_items_on_scale = lines * ctrl->n_o_items_on_scale;
        9: 1517:    m->segments_per_item = ctrl->segments_per_item;
        -: 1518:
        9: 1519:    return m;
        -: 1520:
        -: 1521:}
        -: 1522:
        2: 1523:menu *menu_new_root(menu_ctrl *ctrl, int lines) {
        2: 1524:    menu *m = menu_new(ctrl,lines);
        2: 1525:    ctrl->n_roots = ctrl->n_roots + 1;
        2: 1526:    ctrl->root = realloc(ctrl->root,ctrl->n_roots * sizeof(menu *));
        2: 1527:    ctrl->root[ctrl->n_roots-1] = m;
        2: 1528:    return m;
        -: 1529:}
        -: 1530:
    #####: 1531:void menu_dispose(menu *menu) {
    #####: 1532:    if (!menu) {
        -: 1533:        return;
        -: 1534:    }
        -: 1535:
    #####: 1536:    menu_clear(menu);
        -: 1537:
        -: 1538:}
        -: 1539:
        6: 1540:menu_item *menu_add_sub_menu(menu *m, const char *label, menu *sub_menu, item_action *action) {
        -: 1541:
        6: 1542:    menu_item *item = menu_item_new(m, label, NULL, UNKNOWN_OBJECT_TYPE, NULL, -1, action, NULL, -1);
        6: 1543:    item->sub_menu = sub_menu;
        6: 1544:    item->is_sub_menu = 1;
        6: 1545:    sub_menu->parent = m;
        -: 1546:
        6: 1547:    return item;
        -: 1548:
        -: 1549:}
        -: 1550:
    #####: 1551:menu_item *menu_new_sub_menu(menu *m, const char *label, item_action *action) {
        -: 1552:
    #####: 1553:    menu *sub_menu = malloc(sizeof(menu));
        -: 1554:
    #####: 1555:    sub_menu->max_id = -1;
    #####: 1556:    sub_menu->active_id = -1;
    #####: 1557:    sub_menu->current_id = 0;
        -: 1558:
    #####: 1559:    sub_menu->radius_labels = m->ctrl->radius_labels;
    #####: 1560:    sub_menu->radius_scales_start = m->ctrl->radius_scales_start;
    #####: 1561:    sub_menu->radius_scales_end = m->ctrl->radius_scales_end;
        -: 1562:
    #####: 1563:    sub_menu->parent = m;
    #####: 1564:    sub_menu->item = 0;
    #####: 1565:    sub_menu->segment = 0;
    #####: 1566:    sub_menu->n_o_lines = 1;
    #####: 1567:    sub_menu->label = 0;
    #####: 1568:    sub_menu->object = 0;
        -: 1569:
    #####: 1570:    sub_menu->ctrl = m->ctrl;
    #####: 1571:    sub_menu->n_o_items_on_scale = m->n_o_items_on_scale;
        -: 1572:
    #####: 1573:    menu_item *item = menu_item_new(m, label, NULL, UNKNOWN_OBJECT_TYPE, NULL, -1, action, NULL, -1);
    #####: 1574:    item->sub_menu = sub_menu;
    #####: 1575:    item->is_sub_menu = 1;
        -: 1576:
    #####: 1577:    return item;
        -: 1578:
        -: 1579:}
        -: 1580:
      124: 1581:void menu_turn(menu *m, int direction) {
      124: 1582:    menu_ctrl *ctrl = (menu_ctrl *) m->ctrl;
      124: 1583:    ctrl->warping = 1;
      124: 1584:    unsigned int total_n_o_segments = m->n_o_items_on_scale * (2.0*m->segments_per_item+1);
      124: 1585:    m->segment = m->segment + direction;
      124: 1586:    m->dirty = 1;
      124: 1587:    if (m->segment > m->segments_per_item) {
       13: 1588:        m->segment = -m->segments_per_item;
       13: 1589:        m->current_id = m->current_id - 1;
       13: 1590:        if (m->current_id < 0) {
        3: 1591:            m->current_id = m->max_id;
        -: 1592:        }
      111: 1593:    } else if (m->segment < -m->segments_per_item) {
        4: 1594:        m->segment = m->segments_per_item;
        4: 1595:        m->current_id = m->current_id + 1;
        4: 1596:        if (m->current_id > m->max_id) {
    #####: 1597:            m->current_id = 0;
        -: 1598:        }
        -: 1599:    }
      124: 1600:    ctrl->bg_segment = ctrl->bg_segment + direction;
      124: 1601:    if (ctrl->bg_segment >= total_n_o_segments) {
        4: 1602:        ctrl->bg_segment = 0;
      120: 1603:    } else if (ctrl->bg_segment < 0) {
        2: 1604:        ctrl->bg_segment = total_n_o_segments - 1;
        -: 1605:
        -: 1606:    }
      124: 1607:    menu_ctrl_draw(m->ctrl);
      124: 1608:}
        -: 1609:
       94: 1610:void menu_turn_right(menu *m) {
       94: 1611:    menu_turn(m,1);
       94: 1612:}
        -: 1613:
       30: 1614:void menu_turn_left(menu *m) {
       30: 1615:    menu_turn(m,-1);
       30: 1616:}
        -: 1617:
    #####: 1618:menu_ctrl *menu_get_ctrl(menu *m) {
    #####: 1619:    return m->ctrl;
        -: 1620:}
        -: 1621:
    #####: 1622:int menu_get_current_id(menu *menu) {
    #####: 1623:    return menu->current_id;
        -: 1624:}
        -: 1625:
    #####: 1626:void menu_set_current_id(menu *menu, int id) {
    #####: 1627:    if (menu->max_id >= id) {
    #####: 1628:        menu->current_id = id;
    #####: 1629:        if (menu_item_is_sub_menu(menu_get_item(menu,id))) {
    #####: 1630:        }
        -: 1631:    }
    #####: 1632:}
        -: 1633:
        1: 1634:void menu_set_radius(menu *m, int radius_labels, int radius_scales_start, int radius_scales_end) {
        -: 1635:
        1: 1636:    if (radius_labels >= 0)
        1: 1637:        m->radius_labels = radius_labels;
        1: 1638:    if (radius_scales_start >= 0)
        1: 1639:        m->radius_scales_start = radius_scales_start;
        1: 1640:    if (radius_scales_end >= 0)
        1: 1641:        m->radius_scales_end = radius_scales_end;
        -: 1642:
        -: 1643:    int i = 0;
       1*: 1644:    for (i = 0; i < m->max_id; i++) {
    #####: 1645:        if (m->item[i] && m->item[i]->is_sub_menu) {
    #####: 1646:            menu_set_radius((menu *) m->item[i]->sub_menu, radius_labels, radius_scales_start, radius_scales_end);
        -: 1647:        }
        -: 1648:    }
        -: 1649:
        1: 1650:}
        -: 1651:
        1: 1652:void menu_update_cnt_rad(menu *m, SDL_Point center, int radius) {
       1*: 1653:    for (int i = 0; i < m->max_id; i++) {
    #####: 1654:        if (m->item[i]) {
    #####: 1655:            if (m->item[i]->is_sub_menu) {
    #####: 1656:                menu_update_cnt_rad((menu *) m->item[i]->sub_menu, center, radius);
        -: 1657:            } else {
    #####: 1658:                menu_item_update_cnt_rad(m->item[i],center,radius);
        -: 1659:            }
        -: 1660:        }
        -: 1661:    }
        1: 1662:}
        -: 1663:
        1: 1664:void menu_rebuild_glyphs(menu *m) {
       1*: 1665:    for (int i = 0; i < m->max_id; i++) {
    #####: 1666:        if (m->item[i]) {
    #####: 1667:            if (m->item[i]->is_sub_menu) {
    #####: 1668:                menu_rebuild_glyphs((menu *) m->item[i]->sub_menu);
        -: 1669:            } else {
    #####: 1670:                menu_item_rebuild_glyphs(m->item[i]);
        -: 1671:            }
        -: 1672:        }
        -: 1673:    }
        1: 1674:}
        -: 1675:
        1: 1676:int menu_set_colors(menu *m, SDL_Color *default_color, SDL_Color *selected_color) {
        1: 1677:    m->default_color = default_color;
        1: 1678:    m->selected_color = selected_color;
        1: 1679:    menu_rebuild_glyphs(m);
        -: 1680:
        1: 1681:    return 1;
        -: 1682:
        -: 1683:}
        -: 1684:
        2: 1685:int menu_set_bg_image(menu *m, char *bgImagePath) {
        -: 1686:
        2: 1687:    if (m->bg_image) {
        1: 1688:        SDL_DestroyTexture(m->bg_image);
        1: 1689:        m->bg_image = NULL;
        -: 1690:    }
        -: 1691:
        2: 1692:    if (bgImagePath) {
        2: 1693:        m->bg_image = IMG_LoadTexture(m->ctrl->renderer,bgImagePath);
        2: 1694:        if (!m->bg_image) {
    #####: 1695:            log_error(MENU_CTX, "Could not load background image %s: %s\n", bgImagePath, SDL_GetError());
        -: 1696:        }
        -: 1697:    } else {
    #####: 1698:        m->bg_image = NULL;
        -: 1699:    }
        -: 1700:
        2: 1701:    return 1;
        -: 1702:
        -: 1703:}
        -: 1704:
        6: 1705:int open_parent_menu(void *ctrl_ptr) {
        6: 1706:    menu_ctrl *ctrl = (menu_ctrl *) ctrl_ptr;
        6: 1707:        menu *current = ctrl->current;
        6: 1708:    if (current->parent) {
        6: 1709:        menu_fade_in(current, current->parent);
        6: 1710:        ctrl->current = current->parent;
        6: 1711:        if (!current->transient) {
        6: 1712:            ctrl->active = ctrl->current;
        -: 1713:        }
        6: 1714:        if (ctrl->action) {
        6: 1715:            ctrl->action(CLOSE,current->parent,NULL);
        -: 1716:        }
        6: 1717:        return 1;
        -: 1718:    }
        -: 1719:    return 0;
        -: 1720:}
        -: 1721:
      118: 1722:int menu_action(menu_event evt, menu_ctrl *ctrl, menu_item *item) {
      118: 1723:    if (item) {
       22: 1724:        if(item->is_sub_menu) {
        -: 1725:
        6: 1726:            if (item->action) {
        1: 1727:                ((item_action*)item->action)(evt, item->menu, item);
        -: 1728:            }
        -: 1729:
        6: 1730:            return menu_open_sub_menu(ctrl, item);
      16*: 1731:        } else if (item->object_type == OBJECT_TYPE_ACTION && item->action) {
    #####: 1732:            return ((item_action*)item->action)(evt, item->menu, item);
        -: 1733:        }
        -: 1734:    }
      112: 1735:    if (ctrl->action) {
      112: 1736:        return ctrl->action(evt, ctrl->current, item);
        -: 1737:    }
        -: 1738:    return 1;
        -: 1739:}
        -: 1740:
        1: 1741:void menu_ctrl_set_offset(menu_ctrl *ctrl, int x_offset, int y_offset) {
        1: 1742:    ctrl->x_offset = x_offset;
        1: 1743:    ctrl->y_offset = y_offset;
        1: 1744:    SDL_Point center;
        -: 1745:
        1: 1746:    center.x = ctrl->x_offset + ctrl->w / 2.0;
        1: 1747:    center.y = ctrl->y_offset + 0.5 * ctrl->offset * ctrl->w;
        -: 1748:
        1: 1749:    ctrl->center = center;
        -: 1750:
        2: 1751:    for (int r = 0; r < ctrl->n_roots; r++) {
        1: 1752:        menu_update_cnt_rad(ctrl->root[r],ctrl->center,ctrl->radius_labels);
        -: 1753:    }
        -: 1754:
        1: 1755:}
        -: 1756:
    #####: 1757:int menu_ctrl_get_x_offset(menu_ctrl *ctrl) {
    #####: 1758:    return ctrl->x_offset;
        -: 1759:}
        -: 1760:
    #####: 1761:void menu_ctrl_set_x_offset(menu_ctrl *ctrl, int x) {
    #####: 1762:    menu_ctrl_set_offset(ctrl,x,ctrl->y_offset);
    #####: 1763:}
        -: 1764:
    #####: 1765:int menu_ctrl_get_y_offset(menu_ctrl *ctrl) {
    #####: 1766:    return ctrl->y_offset;
        -: 1767:}
        -: 1768:
    #####: 1769:void menu_ctrl_set_y_offset(menu_ctrl *ctrl, int y) {
    #####: 1770:    ctrl->y_offset = y;
    #####: 1771:}
        -: 1772:
    #####: 1773:void menu_ctrl_set_angle_offset(menu_ctrl *ctrl, double a) {
    #####: 1774:    ctrl->angle_offset = a;
    #####: 1775:}
        -: 1776:
    #####: 1777:int menu_ctrl_get_label_radius(menu_ctrl *ctrl) {
    #####: 1778:    return ctrl->root[0]->radius_labels;
        -: 1779:}
        -: 1780:
    #####: 1781:void menu_ctrl_set_label_radius(menu_ctrl *ctrl, int radius) {
        -: 1782:
    #####: 1783:    if (ctrl->root) {
    #####: 1784:        for (int r = 0; r < ctrl->n_roots; r++) {
    #####: 1785:            menu_set_radius(ctrl->root[r], radius, ctrl->root[r]->radius_scales_start, ctrl->root[r]->radius_scales_end);
        -: 1786:        }
        -: 1787:    }
        -: 1788:
    #####: 1789:}
        -: 1790:
    #####: 1791:int menu_ctrl_get_scales_radius_start(menu_ctrl *ctrl) {
    #####: 1792:    if (ctrl->root) {
    #####: 1793:        return ctrl->root[0]->radius_scales_start;
        -: 1794:    }
        -: 1795:    return 0;
        -: 1796:}
        -: 1797:
    #####: 1798:void menu_ctrl_set_scales_radius_start(menu_ctrl *ctrl, int radius) {
        -: 1799:
    #####: 1800:    if (ctrl->root) {
    #####: 1801:        for (int r = 0; r < ctrl->n_roots; r++) {
    #####: 1802:            menu_set_radius(ctrl->root[r], ctrl->root[r]->radius_labels, radius, ctrl->root[r]->radius_scales_end);
        -: 1803:        }
        -: 1804:    }
        -: 1805:
    #####: 1806:}
        -: 1807:
    #####: 1808:int menu_ctrl_get_scales_radius_end(menu_ctrl *ctrl) {
    #####: 1809:    if (ctrl->root) {
    #####: 1810:        return ctrl->root[0]->radius_scales_end;
        -: 1811:    }
        -: 1812:    return 0;
        -: 1813:}
        -: 1814:
    #####: 1815:void menu_ctrl_set_scales_radius_end(menu_ctrl *ctrl, int radius) {
        -: 1816:
    #####: 1817:    if (ctrl->root) {
    #####: 1818:        for (int r = 0; r < ctrl->n_roots; r++) {
    #####: 1819:            menu_set_radius(ctrl->root[r], ctrl->root[r]->radius_labels, ctrl->root[r]->radius_scales_end, radius);
        -: 1820:        }
        -: 1821:    }
        -: 1822:
    #####: 1823:}
        -: 1824:
    #####: 1825:menu *menu_ctrl_get_current(menu_ctrl *ctrl) {
    #####: 1826:    return ctrl->current;
        -: 1827:}
        -: 1828:
    #####: 1829:void menu_ctrl_set_current(menu_ctrl *ctrl, menu *menu) {
    #####: 1830:    ctrl->current = menu;
    #####: 1831:}
        -: 1832:
    #####: 1833:menu *menu_ctrl_get_root(menu_ctrl *ctrl) {
    #####: 1834:    return ctrl->root[0];
        -: 1835:}
        -: 1836:
    35532: 1837:int menu_ctrl_draw_scale(menu_ctrl *ctrl, double xc, double yc, double r, double R, double angle, unsigned char alpha, int lines) {
    35532: 1838:    double a = M_PI * angle / 180.0;
    35532: 1839:    double cos_a = cos(a);
    35532: 1840:    double sin_a = sin(a);
    35532: 1841:    double fx1 = xc + r * cos_a;
    35532: 1842:    double fy1 = yc - r * sin_a;
    35532: 1843:    double fx2 = xc + R * cos_a;
    35532: 1844:    double fy2 = yc - R * sin_a;
        -: 1845:
        -: 1846:    /**
        -: 1847:     * Decide whether we have to draw
        -: 1848:     */
    35532: 1849:    int doDraw = 1;
   35532*: 1850:    if (fx1 > ctrl->w && fx2 > ctrl->w) {
        -: 1851:        doDraw = 0;
   35532*: 1852:    } else if (fx1 < 0 && fx2 < 0) {
        -: 1853:        doDraw = 0;
    35532: 1854:    } else if (fy1 > ctrl->h && fx2 > ctrl->h) {
        -: 1855:        doDraw = 0;
   26831*: 1856:    } else if (fy1 < 0 && fx2 < 0) {
        -: 1857:        doDraw = 0;
        -: 1858:    }
        -: 1859:
        -: 1860:    if (doDraw) {
    26831: 1861:        if (lines == 1) {
    #####: 1862:            SDL_SetRenderDrawBlendMode(ctrl->renderer,SDL_BLENDMODE_BLEND);
    #####: 1863:            SDL_SetRenderDrawColor(ctrl->renderer, ctrl->scale_color->r, ctrl->scale_color->g, ctrl->scale_color->b, alpha/2);
    #####: 1864:            SDL_RenderDrawLineF(ctrl->renderer, fx1-1, fy1, fx2-1, fy2);
    #####: 1865:            SDL_RenderDrawLineF(ctrl->renderer, fx1+1, fy1, fx2+1, fy2);
        -: 1866:        }
    26831: 1867:        SDL_SetRenderDrawBlendMode(ctrl->renderer,SDL_BLENDMODE_NONE);
    26831: 1868:        SDL_SetRenderDrawColor(ctrl->renderer, ctrl->scale_color->r, ctrl->scale_color->g, ctrl->scale_color->b, alpha);
    26831: 1869:        SDL_RenderDrawLineF(ctrl->renderer, fx1, fy1, fx2, fy2);
        -: 1870:    }
        -: 1871:
    35532: 1872:    return 0;
        -: 1873:}
        -: 1874:
      329: 1875:int menu_ctrl_apply_light(menu_ctrl *ctrl) {
      329: 1876:    if (ctrl->light_texture) {
      328: 1877:        double w = ctrl->w;
      328: 1878:        double h = ctrl->h;
      328: 1879:        double xo = ctrl->center.x - 0.5 * ctrl->w;
      328: 1880:        double yo = 0;
      328: 1881:        const SDL_Rect dst_rect = {xo, yo, w, h};
      328: 1882:        SDL_RenderCopy(ctrl->renderer,ctrl->light_texture,NULL,&dst_rect);
        -: 1883:    }
        -: 1884:
      329: 1885:    return 0;
        -: 1886:
        -: 1887:}
        -: 1888:
    #####: 1889:int menu_ctrl_clear(menu_ctrl *ctrl, double angle) {
    #####: 1890:    do_clear(ctrl, angle, ctrl->background_color, ctrl->bg_image);
    #####: 1891:    return 1;
        -: 1892:}
        -: 1893:
        1: 1894:void menu_ctrl_set_radii(menu_ctrl *ctrl, int radius_labels, int radius_scales_start, int radius_scales_end) {
        -: 1895:
        1: 1896:    if (ctrl->root) {
        2: 1897:        for (int r = 0; r < ctrl->n_roots; r++) {
        1: 1898:            menu_set_radius(ctrl->root[r], radius_labels, radius_scales_start, radius_scales_end);
        -: 1899:        }
        -: 1900:    }
        -: 1901:
        1: 1902:}
        -: 1903:
    #####: 1904:int menu_ctrl_set_bg_color_hsv(menu_ctrl *ctrl, double h, double s, double v) {
    #####: 1905:    log_config(MENU_CTX, "free(ctrl->background_color -> %p)\n", ctrl->background_color);
    #####: 1906:    free(ctrl->background_color);
    #####: 1907:    ctrl->background_color = hsv_to_color(h, s, v);
    #####: 1908:    return 1;
        -: 1909:}
        -: 1910:
    #####: 1911:int menu_ctrl_set_default_color_hsv(menu_ctrl *ctrl, double h, double s, double v) {
    #####: 1912:    log_config(MENU_CTX, "free(ctrl->default_color -> %p)\n", ctrl->default_color);
    #####: 1913:    free(ctrl->default_color);
    #####: 1914:    ctrl->default_color = hsv_to_color(h, s, v);
        -: 1915:
    #####: 1916:    for (int r = 0; r < ctrl->n_roots; r++) {
    #####: 1917:        menu_rebuild_glyphs(ctrl->root[r]);
        -: 1918:    }
        -: 1919:
    #####: 1920:    return 1;
        -: 1921:}
        -: 1922:
    #####: 1923:int menu_ctrl_set_active_color_hsv(menu_ctrl *ctrl, double h, double s, double v) {
    #####: 1924:    log_config(MENU_CTX, "free(ctrl->activated_color -> %p)\n", ctrl->activated_color);
    #####: 1925:    free(ctrl->activated_color);
    #####: 1926:    ctrl->activated_color = hsv_to_color(h, s, v);
        -: 1927:
    #####: 1928:    for (int r = 0; r < ctrl->n_roots; r++) {
    #####: 1929:        menu_rebuild_glyphs(ctrl->root[r]);
        -: 1930:    }
        -: 1931:
    #####: 1932:    return 1;
        -: 1933:}
        -: 1934:
    #####: 1935:int menu_ctrl_set_selected_color_hsv(menu_ctrl *ctrl, double h, double s, double v) {
    #####: 1936:    log_config(MENU_CTX, "free(ctrl->selected_color -> %p)\n", ctrl->selected_color);
    #####: 1937:    free(ctrl->selected_color);
    #####: 1938:    ctrl->selected_color = hsv_to_color(h, s, v);
        -: 1939:
    #####: 1940:    for (int r = 0; r < ctrl->n_roots; r++) {
    #####: 1941:        menu_rebuild_glyphs(ctrl->root[r]);
        -: 1942:    }
        -: 1943:
    #####: 1944:    return 1;
        -: 1945:}
        -: 1946:
    #####: 1947:int menu_ctrl_set_bg_color_rgb(menu_ctrl *ctrl, Uint8 r, Uint8 g, Uint8 b) {
    #####: 1948:    log_config(MENU_CTX, "free(ctrl->background_color -> %p)\n", ctrl->background_color);
    #####: 1949:    free(ctrl->background_color);
    #####: 1950:    ctrl->background_color = rgb_to_color(r,g,b);
    #####: 1951:    return 1;
        -: 1952:}
        -: 1953:
    #####: 1954:int menu_ctrl_set_default_color_rgb(menu_ctrl *ctrl, Uint8 r, Uint8 g, Uint8 b) {
    #####: 1955:    log_config(MENU_CTX, "free(ctrl->default_color -> %p)\n", ctrl->default_color);
    #####: 1956:    free(ctrl->default_color);
    #####: 1957:    ctrl->default_color = rgb_to_color(r,g,b);
        -: 1958:
    #####: 1959:    for (int r = 0; r < ctrl->n_roots; r++) {
    #####: 1960:        menu_rebuild_glyphs(ctrl->root[r]);
        -: 1961:    }
        -: 1962:
    #####: 1963:    return 1;
        -: 1964:}
        -: 1965:
    #####: 1966:int menu_ctrl_set_active_color_rgb(menu_ctrl *ctrl, Uint8 r, Uint8 g, Uint8 b) {
    #####: 1967:    log_config(MENU_CTX, "menu_ctrl_set_active_color_rgb: (%d,%d,%d)\n", ctrl->activated_color->r,ctrl->activated_color->g,ctrl->activated_color->b);
    #####: 1968:    free(ctrl->activated_color);
    #####: 1969:    ctrl->activated_color = rgb_to_color(r,g,b);
    #####: 1970:    ctrl->default_color = ctrl->activated_color;
    #####: 1971:    ctrl->selected_color = ctrl->activated_color;
    #####: 1972:    log_config(MENU_CTX, " -> (%d,%d,%d)\n", ctrl->activated_color->r,ctrl->activated_color->g,ctrl->activated_color->b);
        -: 1973:
    #####: 1974:    for (int r = 0; r < ctrl->n_roots; r++) {
    #####: 1975:        menu_rebuild_glyphs(ctrl->root[r]);
        -: 1976:    }
        -: 1977:
    #####: 1978:    return 1;
        -: 1979:}
        -: 1980:
    #####: 1981:int menu_ctrl_set_selected_color_rgb(menu_ctrl *ctrl, Uint8 r, Uint8 g, Uint8 b) {
    #####: 1982:    log_config(MENU_CTX, "free(ctrl->selected_color -> %p)\n", ctrl->selected_color);
    #####: 1983:    free(ctrl->selected_color);
    #####: 1984:    ctrl->selected_color = rgb_to_color(r,g,b);
        -: 1985:
    #####: 1986:    for (int r = 0; r < ctrl->n_roots; r++) {
    #####: 1987:        menu_rebuild_glyphs(ctrl->root[r]);
        -: 1988:    }
        -: 1989:
    #####: 1990:    return 1;
        -: 1991:}
        -: 1992:
      284: 1993:int menu_ctrl_draw(menu_ctrl *ctrl) {
      284: 1994:    return menu_draw(ctrl->current, 1, 1);
        -: 1995:}
        -: 1996:
        2: 1997:int menu_ctrl_set_style(menu_ctrl *ctrl, char *background, char *scale, char *indicator,
        -: 1998:                        char *def, char *selected, char *activated, char *bgImagePath, int bg_from_time, int draw_scales, int font_bumpmap, int shadow_offset, Uint8 shadow_alpha, char **bg_color_palette, int bg_cp_colors, char **fg_color_palette, int fg_cp_colors) {
        2: 1999:    log_config(MENU_CTX, "START: menu_ctrl_set_style (");
        2: 2000:    log_config(MENU_CTX, "background -> %s", background);
        2: 2001:    log_config(MENU_CTX, ", scale -> %s", scale);
        2: 2002:    log_config(MENU_CTX, ", def -> %s", def);
        2: 2003:    log_config(MENU_CTX, ", selected -> %s", selected);
        2: 2004:    log_config(MENU_CTX, ", activated -> %s", activated);
        2: 2005:    log_config(MENU_CTX, ", indicator -> %s", indicator);
        2: 2006:    log_config(MENU_CTX, ", bgImagePath -> %s", bgImagePath);
        2: 2007:    log_config(MENU_CTX, ")\n");
        2: 2008:    if (ctrl->background_color) {
        1: 2009:        free(ctrl->background_color);
        -: 2010:    }
        2: 2011:    ctrl->background_color = html_to_color(background);
        -: 2012:
        2: 2013:    if (ctrl->scale_color) {
        1: 2014:        free(ctrl->scale_color);
        -: 2015:    }
        2: 2016:    ctrl->scale_color = html_to_color(scale);
        -: 2017:
        2: 2018:    if (ctrl->default_color) {
        1: 2019:        free(ctrl->default_color);
        -: 2020:    }
        2: 2021:    ctrl->default_color = html_to_color(def);
        -: 2022:
        2: 2023:    if (ctrl->selected_color) {
        1: 2024:        free(ctrl->selected_color);
        -: 2025:    }
        2: 2026:    ctrl->selected_color = html_to_color(selected);
        -: 2027:
        2: 2028:    if (ctrl->activated_color) {
        1: 2029:        free(ctrl->activated_color);
        -: 2030:    }
        2: 2031:    ctrl->activated_color = html_to_color(activated);
        -: 2032:
        2: 2033:    if (ctrl->indicator_color) {
        1: 2034:        free(ctrl->indicator_color);
        -: 2035:    }
        2: 2036:    ctrl->indicator_color = html_to_color_and_alpha(indicator,&(ctrl->indicator_alpha));
        -: 2037:
        2: 2038:    if (ctrl->indicator_color_light) {
        1: 2039:        free(ctrl->indicator_color_light);
        -: 2040:    }
        2: 2041:    ctrl->indicator_color_light = color_between(ctrl->indicator_color, &white, 0.85);
        -: 2042:
        2: 2043:    if (ctrl->indicator_color_dark) {
        1: 2044:        free(ctrl->indicator_color_dark);
        -: 2045:    }
        2: 2046:    ctrl->indicator_color_dark = color_between(ctrl->indicator_color, &black, 0.85);
        -: 2047:
        2: 2048:    if (bg_from_time == 1) {
    #####: 2049:        ctrl->bg_color_of_time = 1;
        -: 2050:    } else {
        2: 2051:        ctrl->bg_color_of_time = 0;
        -: 2052:    }
        -: 2053:
        2: 2054:    if (ctrl->bg_image) {
    #####: 2055:        SDL_DestroyTexture(ctrl->bg_image);
    #####: 2056:        ctrl->bg_image = NULL;
        -: 2057:    }
        -: 2058:
        2: 2059:    if (bgImagePath) {
        1: 2060:        ctrl->bg_image = IMG_LoadTexture(ctrl->renderer,bgImagePath);
        1: 2061:        if (!ctrl->bg_image) {
    #####: 2062:            log_error(MENU_CTX, "Could not load background image %s: %s\n", bgImagePath, SDL_GetError());
        -: 2063:        }
        -: 2064:    } else {
        1: 2065:        ctrl->bg_image = NULL;
        -: 2066:    }
        -: 2067:
        2: 2068:    if (bg_color_palette) {
    #####: 2069:        ctrl->bg_color_palette = bg_color_palette;
    #####: 2070:        ctrl->bg_cp_colors = bg_cp_colors;
        -: 2071:    }
        -: 2072:
        2: 2073:    if (fg_color_palette) {
    #####: 2074:        ctrl->fg_color_palette = fg_color_palette;
    #####: 2075:        ctrl->fg_cp_colors = fg_cp_colors;
        -: 2076:    }
        -: 2077:
        2: 2078:    ctrl->font_bumpmap = font_bumpmap;
        2: 2079:    ctrl->shadow_offset = shadow_offset;
        2: 2080:    ctrl->shadow_alpha = shadow_alpha;
        -: 2081:
        2: 2082:    log_info(MENU_CTX, "Colors:\n");
        2: 2083:    html_print_color("Background", ctrl->background_color);
        2: 2084:    html_print_color("Default", ctrl->default_color);
        2: 2085:    html_print_color("Scale", ctrl->scale_color);
        2: 2086:    html_print_color("Indicator", ctrl->indicator_color);
        2: 2087:    html_print_color("Selected", ctrl->selected_color);
        2: 2088:    html_print_color("Activated", ctrl->activated_color);
        -: 2089:
        2: 2090:    int draw_res = menu_ctrl_draw(ctrl);
        2: 2091:    log_config(MENU_CTX, "END: menu_ctrl_set_style\n");
        2: 2092:    return draw_res;
        -: 2093:
        -: 2094:}
        -: 2095:
        1: 2096:int menu_ctrl_apply_theme(menu_ctrl *ctrl, theme *theme) {
        2: 2097:    return menu_ctrl_set_style(ctrl, theme->background_color, theme->scale_color,
        -: 2098:                               theme->indicator_color, theme->default_color, theme->selected_color,
        1: 2099:                               theme->activated_color, theme->bg_image_path, theme->bg_color_of_time, 1, theme->font_bumpmap, theme->shadow_offset, theme->shadow_alpha, theme->bg_color_palette, theme->bg_cp_colors, theme->fg_color_palette, theme->fg_cp_colors);
        -: 2100:}
        -: 2101:
        1: 2102:void menu_ctrl_set_light(menu_ctrl *ctrl, double light_x, double light_y, double radius, double alpha) {
        1: 2103:    if (ctrl->light_texture) {
    #####: 2104:        SDL_DestroyTexture(ctrl->light_texture);
    #####: 2105:        free(ctrl->light_texture);
        -: 2106:    }
        1: 2107:    ctrl->light_x = light_x;
        1: 2108:    ctrl->light_y = light_y;
        -: 2109:
        1: 2110:    ctrl->light_texture = new_light_texture(ctrl->renderer, ctrl->w, ctrl->h, light_x, light_y, radius, alpha);
        -: 2111:
        1: 2112:}
        -: 2113:
        1: 2114:void menu_ctrl_set_light_img(menu_ctrl *ctrl, char *path) {
        1: 2115:    if (ctrl->light_texture) {
        1: 2116:        SDL_DestroyTexture(ctrl->light_texture);
        -: 2117:    }
        -: 2118:
        1: 2119:    ctrl->light_texture = load_light_texture(ctrl->renderer,path);
        -: 2120:
        1: 2121:}
        -: 2122:
        1: 2123:menu_ctrl *menu_ctrl_new(int w, int x_offset, int y_offset, int radius_labels, int draw_scales, int radius_scales_start, int radius_scales_end, double angle_offset, const char *font, int font_size, int font_size2,
        -: 2124:                         item_action *action, menu_callback *call_back) {
        -: 2125:
        1: 2126:    log_config(MENU_CTX, "Initializing menu of width %d\n", w);
        1: 2127:    menu_ctrl *ctrl = calloc(1,sizeof(menu_ctrl));
        -: 2128:
        1: 2129:    ctrl->warping = 0;
        -: 2130:
        1: 2131:    ctrl->radius_labels = radius_labels;
        1: 2132:    ctrl->radius_scales_start = radius_scales_start;
        1: 2133:    ctrl->radius_scales_end = radius_scales_end;
        1: 2134:    ctrl->draw_scales = draw_scales;
        1: 2135:    ctrl->no_of_scales = 36;
        1: 2136:    ctrl->n_o_items_on_scale = 4;
        1: 2137:    ctrl->segments_per_item = 3;
        -: 2138:
        1: 2139:    ctrl->w = w;
       1*: 2140:    ctrl->h = to_int(0.65 * w);
        -: 2141:
        1: 2142:    ctrl->root = malloc(sizeof(menu *));
        1: 2143:    ctrl->n_roots = 1;
        -: 2144:
        1: 2145:    menu *root = malloc(sizeof(menu));
        -: 2146:
        1: 2147:    root->max_id = -1;
        1: 2148:    root->item = 0x0;
        1: 2149:    root->active_id = -1;
        1: 2150:    root->current_id = 0;
        1: 2151:    root->segment = 0;
        1: 2152:    root->parent = 0;
        1: 2153:    root->label = 0;
        1: 2154:    root->transient = 0;
        1: 2155:    root->draw_only_active = 0;
        1: 2156:    root->object = 0;
        1: 2157:    root->n_o_lines = 1;
        1: 2158:    root->n_o_items_on_scale = ctrl->n_o_items_on_scale;
        1: 2159:    root->segments_per_item = ctrl->segments_per_item;
        -: 2160:
        1: 2161:    ctrl->root[0] = root;
        -: 2162:
        1: 2163:    ctrl->offset = 1.2;
        -: 2164:
        1: 2165:    menu_ctrl_set_offset(ctrl,x_offset,y_offset);
        -: 2166:
        1: 2167:    ctrl->font_size = font_size;
        1: 2168:    if (font_size2 > 0) {
    #####: 2169:        ctrl->font_size2 = font_size2;
        -: 2170:    } else {
        1: 2171:        ctrl->font_size2 = font_size - 8;
        -: 2172:    }
        -: 2173:
        1: 2174:    ctrl->light_x = 0.0;
        1: 2175:    ctrl->light_y = 0.0;
        -: 2176:
        1: 2177:    ctrl->angle_offset = angle_offset;
        -: 2178:
        1: 2179:    ctrl->current = ctrl->root[0];
        1: 2180:    ctrl->active = ctrl->root[0];
        1: 2181:    ctrl->root[0]->ctrl = ctrl;
        -: 2182:
        1: 2183:    menu_ctrl_set_radii(ctrl,radius_labels,radius_scales_start,radius_scales_end);
        -: 2184:
        1: 2185:    ctrl->call_back = call_back;
        1: 2186:    ctrl->action = action;
        1: 2187:    ctrl->bg_image = 0;
        -: 2188:
        1: 2189:    ctrl->bg_color_palette = NULL;
        1: 2190:    ctrl->bg_cp_colors = 0;
        -: 2191:
        1: 2192:    if (!init_SDL()) {
    #####: 2193:        log_error(MENU_CTX, "Failed to initialize SDL\n");
    #####: 2194:        return 0;
        -: 2195:    }
        -: 2196:
        1: 2197:    if (font) {
        1: 2198:        log_config(MENU_CTX, "Trying to open font %s\n", font);
        1: 2199:        ctrl->font = TTF_OpenFont(font, font_size);
        1: 2200:        ctrl->font2 = TTF_OpenFont(font, ctrl->font_size2);
        -: 2201:    }
        -: 2202:
        1: 2203:    if (!ctrl->font) {
    #####: 2204:        log_error(MENU_CTX, "Failed to load font %s: %s. Trying %s\n", font, SDL_GetError(), FONT_DEFAULT);
    #####: 2205:        ctrl->font = TTF_OpenFont(FONT_DEFAULT, font_size);
    #####: 2206:        ctrl->font2 = TTF_OpenFont(FONT_DEFAULT, ctrl->font_size2);
    #####: 2207:        if (!ctrl->font) {
    #####: 2208:            log_error(MENU_CTX, "Failed to load font %s: %s. Trying /usr/share/fonts/truetype/dejavu/DejaVuSans.ttf.\n", FONT_DEFAULT, SDL_GetError());
    #####: 2209:            ctrl->font = TTF_OpenFont("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", font_size);
    #####: 2210:            ctrl->font2 = TTF_OpenFont("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", ctrl->font_size2);
    #####: 2211:            if (!ctrl->font) {
    #####: 2212:                log_error(MENU_CTX, "Failed to load font: %s\n", SDL_GetError());
        -: 2213:            }
        -: 2214:        }
        -: 2215:    } else {
        1: 2216:        log_config(MENU_CTX, "Font %s successfully opened\n", font);
        -: 2217:    }
        -: 2218:
        1: 2219:    log_info(MENU_CTX, "Creating window...");
        1: 2220:    ctrl->display = SDL_CreateWindow("VE301", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, ctrl->w, ctrl->h, 0);
        1: 2221:    log_info(MENU_CTX, "Done\n");
        1: 2222:    if (ctrl->display) {
        1: 2223:        log_info(MENU_CTX, "Creating renderer...");
        -: 2224:#ifdef RASPBERRY
        -: 2225:        ctrl->renderer = SDL_CreateRenderer(ctrl->display, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
        -: 2226:#else
        1: 2227:        ctrl->renderer = SDL_CreateRenderer(ctrl->display, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
        -: 2228:#endif
        1: 2229:        log_info(MENU_CTX, "Done\n");
        1: 2230:        SDL_RendererInfo rendererInfo;
        1: 2231:        log_info(MENU_CTX, "Getting renderer info...\n");
        1: 2232:        SDL_GetRendererInfo(ctrl->renderer, &rendererInfo);
        1: 2233:        log_info(MENU_CTX, "SDL chose the following renderer:\n");
        1: 2234:        log_info(MENU_CTX, "Renderer: %s software=%d accelerated=%d, presentvsync=%d targettexture=%d\n",
        -: 2235:                  rendererInfo.name,
        -: 2236:                  (rendererInfo.flags & SDL_RENDERER_SOFTWARE) != 0,
        -: 2237:                  (rendererInfo.flags & SDL_RENDERER_ACCELERATED) != 0,
        -: 2238:                  (rendererInfo.flags & SDL_RENDERER_PRESENTVSYNC) != 0,
        -: 2239:                  (rendererInfo.flags & SDL_RENDERER_TARGETTEXTURE) != 0 );
        -: 2240:
        -: 2241:    }
        -: 2242:
        1: 2243:    if (!ctrl->display) {
    #####: 2244:        log_error(MENU_CTX, "Failed to create window: %s\n", SDL_GetError());
    #####: 2245:        return 0;
        -: 2246:    }
        -: 2247:
        -: 2248:#ifdef RASPBERRY
        -: 2249:    menu_ctrl_set_style (ctrl, "#08081e", "#c8c8c8", "#ff0000", "#525239", "#c8c864", "#c8c864", 0, 0, 1, 0, 0, 0, NULL, 0, NULL, 0);
        -: 2250:#else
        1: 2251:    menu_ctrl_set_style(ctrl, "#08081e", "#c8c8c8", "#ff0000", "#525239", "#c8c864",
        -: 2252:                        "#c8c864",
        -: 2253:                        0, 0, 1, 0, 0, 0, NULL, 0, NULL, 0);
        -: 2254:#endif
        -: 2255:
        1: 2256:    return ctrl;
        -: 2257:}
        -: 2258:
     3642: 2259:int menu_ctrl_process_events(menu_ctrl *ctrl) {
     3642: 2260:    int redraw = 0;
        -: 2261:
        -: 2262:#ifdef RASPBERRY
        -: 2263:    int he = next_event ();
        -: 2264:    while (he) {
        -: 2265:        ctrl->warping = 1;
        -: 2266:        log_config (MENU_CTX, "Event: %d\n", he);
        -: 2267:        if (he == BUTTON_A_TURNED_LEFT) {
        -: 2268:            menu_turn_left (ctrl->current);
        -: 2269:            menu_action (TURN_LEFT, ctrl, 0);
        -: 2270:            redraw = 1;
        -: 2271:        } else if (he == BUTTON_A_TURNED_RIGHT) {
        -: 2272:            menu_turn_right (ctrl->current);
        -: 2273:            menu_action (TURN_RIGHT, ctrl, 0);
        -: 2274:            redraw = 1;
        -: 2275:        } else if (he == BUTTON_A_PRESSED) {
        -: 2276:            if (ctrl->current->current_id >= 0 && ctrl->current->item) {
        -: 2277:                menu_item *item = ctrl->current->item[ctrl->current->current_id];
        -: 2278:                menu_action (ACTIVATE, ctrl, item);
        -: 2279:                redraw = 1;
        -: 2280:            } else {
        -: 2281:                log_trace (MENU_CTX, "No action.\n");
        -: 2282:            }
        -: 2283:        } else if (he == BUTTON_A_HOLD) {
        -: 2284:            open_parent_menu (ctrl);
        -: 2285:        } else if (he == BUTTON_B_TURNED_LEFT) {
        -: 2286:            menu_item *item = NULL;
        -: 2287:            if (ctrl->current->current_id >= 0) {
        -: 2288:                item = ctrl->current->item[ctrl->current->current_id];
        -: 2289:            }
        -: 2290:            menu_action(TURN_LEFT_1, ctrl, item);
        -: 2291:        } else if (he == BUTTON_B_TURNED_RIGHT) {
        -: 2292:            menu_item *item = NULL;
        -: 2293:            if (ctrl->current->current_id >= 0) {
        -: 2294:                item = ctrl->current->item[ctrl->current->current_id];
        -: 2295:            }
        -: 2296:            menu_action(TURN_RIGHT_1, ctrl, item);
        -: 2297:        } else if (he == BUTTON_B_PRESSED) {
        -: 2298:            menu_action (ACTIVATE_1, ctrl, 0);
        -: 2299:            //open_parent_menu(ctrl);
        -: 2300:        }
        -: 2301:        he = next_event ();
        -: 2302:    }
        -: 2303:    return redraw;
        -: 2304:#else
     3642: 2305:    SDL_Event e;
        -: 2306:
     4017: 2307:    while (SDL_PollEvent(&e)) {
      376: 2308:        if (e.type == SDL_QUIT) {
        -: 2309:            return -1;
      375: 2310:        } else if (e.type == SDL_MOUSEBUTTONUP) {
       13: 2311:            SDL_MouseButtonEvent *b = (SDL_MouseButtonEvent *) &e;
       13: 2312:            if (b->state == SDL_RELEASED) {
       13: 2313:                if (b->button == 1) {
        7: 2314:                    if (ctrl->current->current_id >= 0) {
        7: 2315:                        menu_item *item =
        7: 2316:                                ctrl->current->item[ctrl->current->current_id];
        7: 2317:                        menu_action(ACTIVATE, ctrl, item);
        7: 2318:                        redraw = 1;
        -: 2319:                    } else {
    #####: 2320:                        log_trace(MENU_CTX, "No action.\n");
        -: 2321:                    }
        6: 2322:                } else if (b->button == 3) {
        6: 2323:                    if (ctrl->current->parent) {
        6: 2324:                        open_parent_menu(ctrl);
        6: 2325:                        redraw = 1;
        -: 2326:                    }
    #####: 2327:                } else if (b->button == 4) {
    #####: 2328:                    menu_turn_left(ctrl->current);
    #####: 2329:                    menu_action(TURN_LEFT, ctrl, 0);
    #####: 2330:                    redraw = 1;
    #####: 2331:                } else if (b->button == 5) {
    #####: 2332:                    menu_turn_right(ctrl->current);
    #####: 2333:                    menu_action(TURN_RIGHT, ctrl, 0);
    #####: 2334:                    redraw = 1;
        -: 2335:                }
        -: 2336:            }
      362: 2337:        } else if (e.type == SDL_MOUSEWHEEL) {
       96: 2338:            SDL_MouseWheelEvent *w = (SDL_MouseWheelEvent *) &e;
       96: 2339:            if (w->y > 0) {
        2: 2340:                menu_turn_left(ctrl->current);
        2: 2341:                menu_action(TURN_LEFT, ctrl, 0);
        2: 2342:                redraw = 1;
       94: 2343:            } else if (w->y < 0) {
       94: 2344:                menu_turn_right(ctrl->current);
       94: 2345:                menu_action(TURN_RIGHT, ctrl, 0);
       94: 2346:                redraw = 1;
        -: 2347:            }
      266: 2348:        } else if (e.type == SDL_KEYUP) {
       15: 2349:            SDL_KeyboardEvent *k = (SDL_KeyboardEvent *) &e;
       15: 2350:            if (k->state == SDL_RELEASED) {
       15: 2351:                if (k->keysym.sym == SDLK_UP) {
        7: 2352:                    menu_item *item = NULL;
        7: 2353:                    if (ctrl->current->current_id >= 0) {
        7: 2354:                        item = ctrl->current->item[ctrl->current->current_id];
        -: 2355:                    }
        7: 2356:                    menu_action(TURN_RIGHT_1, ctrl, item);
        8: 2357:                } else if (k->keysym.sym == SDLK_DOWN) {
        8: 2358:                    menu_item *item = NULL;
        8: 2359:                    if (ctrl->current->current_id >= 0) {
        8: 2360:                        item = ctrl->current->item[ctrl->current->current_id];
        -: 2361:                    }
        8: 2362:                    menu_action(TURN_LEFT_1, ctrl, item);
    #####: 2363:                } else if (k->keysym.sym == SDLK_q) {
        -: 2364:                    return -1;
        -: 2365:                }
        -: 2366:            }
        -: 2367:        }
        -: 2368:    }
        -: 2369:    return redraw;
        -: 2370:#endif
        -: 2371:}
        -: 2372:
        -: 2373:void menu_free(menu *m);
        -: 2374:
        7: 2375:void menu_item_free(menu_item *item) {
        7: 2376:    if (item) {
        7: 2377:        if (item->label_active) {
        7: 2378:            text_obj_free(item->label_active);
        -: 2379:        }
        7: 2380:        if (item->label_current) {
        7: 2381:            text_obj_free(item->label_current);
        -: 2382:        }
        7: 2383:        if (item->label_default) {
        7: 2384:            text_obj_free(item->label_default);
        -: 2385:        }
        7: 2386:        if (item->object) {
    #####: 2387:            if (item->is_sub_menu) {
    #####: 2388:                menu_free((menu *)item->object);
        -: 2389:            } else {
    #####: 2390:                free((void *) item->object);
        -: 2391:            }
        -: 2392:        }
        7: 2393:        free(item);
        -: 2394:    }
        7: 2395:}
        -: 2396:
        3: 2397:void menu_free(menu *m) {
        3: 2398:    if (m) {
       10: 2399:        for (int i = 0; i < m->max_id; i++) {
        7: 2400:            menu_item_free(m->item[i]);
        -: 2401:        }
        3: 2402:        if (m->label) {
    #####: 2403:            free(m->label);
        -: 2404:        }
        3: 2405:        if (m->object) {
    #####: 2406:            free((void *) m->object);
        -: 2407:        }
        3: 2408:        if (m->default_color) {
        1: 2409:            free(m->default_color);
        -: 2410:        }
        3: 2411:        if (m->selected_color) {
        1: 2412:            free(m->selected_color);
        -: 2413:        }
        3: 2414:        free(m);
        -: 2415:    }
        3: 2416:}
        -: 2417:
        1: 2418:void menu_ctrl_free(menu_ctrl *ctrl) {
        1: 2419:    if (ctrl) {
        1: 2420:        if (ctrl->activated_color) {
        1: 2421:            free(ctrl->activated_color);
        -: 2422:        }
        1: 2423:        if (ctrl->background_color) {
        1: 2424:            free(ctrl->background_color);
        -: 2425:        }
        1: 2426:        if (ctrl->default_color) {
        1: 2427:            free(ctrl->default_color);
        -: 2428:        }
        1: 2429:        if (ctrl->indicator_color) {
        1: 2430:            free(ctrl->indicator_color);
        -: 2431:        }
        1: 2432:        if (ctrl->indicator_color_dark) {
        1: 2433:            free(ctrl->indicator_color_dark);
        -: 2434:        }
        1: 2435:        if (ctrl->indicator_color_light) {
        1: 2436:            free(ctrl->indicator_color_light);
        -: 2437:        }
        1: 2438:        if (ctrl->scale_color) {
        1: 2439:            free(ctrl->scale_color);
        -: 2440:        }
        1: 2441:        if (ctrl->selected_color) {
        1: 2442:            free(ctrl->selected_color);
        -: 2443:        }
        1: 2444:        if (ctrl->root) {
        4: 2445:            for (int r = 0; r < ctrl->n_roots; r++) {
        3: 2446:                menu_free(ctrl->root[r]);
        -: 2447:            }
        1: 2448:            ctrl->root = NULL;
        -: 2449:        }
        1: 2450:        if (ctrl->object) {
    #####: 2451:            free(ctrl->object);
        -: 2452:        }
        1: 2453:        if (ctrl->renderer) {
        1: 2454:            SDL_DestroyRenderer(ctrl->renderer);
        -: 2455:        }
        1: 2456:        if (ctrl->display) {
        1: 2457:            SDL_DestroyWindow(ctrl->display);
        -: 2458:        }
        1: 2459:        free(ctrl);
        -: 2460:    }
        1: 2461:}
        -: 2462:
        1: 2463:void menu_ctrl_quit(menu_ctrl *ctrl) {
        1: 2464:    log_info(MENU_CTX, "Cleaning up menu ctrl");
        1: 2465:    menu_ctrl_free(ctrl);
        1: 2466:    log_info(MENU_CTX, "Closing TTF\n");
        1: 2467:    TTF_Quit();
        1: 2468:    log_info(MENU_CTX, "Closing IMG\n");
        1: 2469:    IMG_Quit();
        1: 2470:    log_info(MENU_CTX, "Closing SDL\n");
        1: 2471:    SDL_Quit();
        1: 2472:}
        -: 2473:
        1: 2474:void menu_ctrl_loop(menu_ctrl *ctrl) {
        -: 2475:
        1: 2476:    log_config(MENU_CTX, "START: menu_ctrl_loop\n");
        -: 2477:#ifdef RASPBERRY
        -: 2478:    setup_encoder ();
        -: 2479:#endif
        -: 2480:
        1: 2481:    menu_ctrl_draw(ctrl);
        -: 2482:
     3614: 2483:    while (1) {
     3614: 2484:        int res = menu_ctrl_process_events(ctrl);
     3614: 2485:        log_trace(MENU_CTX, "events result: %d\n", res);
     3614: 2486:        if (res == -1) {
        1: 2487:            menu_ctrl_quit(ctrl);
        1: 2488:            return;
     3613: 2489:        } else if (res == 0) {
     3507: 2490:            if (ctrl->call_back) {
     3507: 2491:                ctrl->call_back(ctrl);
        -: 2492:            }
     3507: 2493:            SDL_Delay(20);
        -: 2494:        } else {
      106: 2495:            menu_ctrl_draw(ctrl);
        -: 2496:        }
        -: 2497:    }
        -: 2498:    log_config(MENU_CTX, "END: menu_ctrl_loop\n");
        -: 2499:}
